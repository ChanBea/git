=pod

=head1 NAME

ASN1_item_sign, ASN1_item_sign_ex, ASN1_item_sign_ctx,
ASN1_item_verify, ASN1_item_verify_ex, ASN1_item_verify_ctx -
ASN1 sign and verify

=head1 SYNOPSIS

 #include <openssl/x509.h>

 int ASN1_item_sign_ex(const ASN1_ITEM *it, X509_ALGOR *algor1,
                       X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
                       const void *data, const ASN1_OCTET_STRING *id,
                       EVP_PKEY *pkey, const EVP_MD *md, OSSL_LIB_CTX *libctx,
                       const char *propq);

 int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2,
                    ASN1_BIT_STRING *signature, const void *data,
                    EVP_PKEY *pkey, const EVP_MD *md);

 int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
                        X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
                        const void *data, EVP_MD_CTX *ctx);

 int ASN1_item_verify_ex(const ASN1_ITEM *it, const X509_ALGOR *alg,
                         const ASN1_BIT_STRING *signature, const void *data,
                         const ASN1_OCTET_STRING *id, EVP_PKEY *pkey,
                         OSSL_LIB_CTX *libctx, const char *propq);

 int ASN1_item_verify(const ASN1_ITEM *it, const X509_ALGOR *alg,
                      const ASN1_BIT_STRING *signature, const void *data,
                      EVP_PKEY *pkey);

 int ASN1_item_verify_ctx(const ASN1_ITEM *it, const X509_ALGOR *alg,
                          const ASN1_BIT_STRING *signature, const void *data,
                          EVP_MD_CTX *ctx);

=head1 DESCRIPTION

ASN1_item_sign_ex() is used to sign arbitrary ASN1 data using a data object
I<data>, the ASN.1 structure I<it>, algorithm identifiers I<algor1> and I<algor2>,
private key I<pkey> and message digest I<md>.
The data that is signed is formed by taking the data object in I<data> and
converting it to der format using the ASN.1 structure I<it>.
Valid values that can be used by the ASN.1 structure I<it> are
ASN1_ITEM_rptr(X509_CINF), ASN1_ITEM_rptr(X509_REQ_INFO) and
ASN1_ITEM_rptr(X509_CRL_INFO).
The B<OSSL_LIB_CTX> specified in I<libctx> and the property query string
specified in I<props> are used when searching for algorithms in providers.
The generated signature is set into I<signature>.
The optional parameter I<id> can be NULL, but can be set for special key types.
See EVP_PKEY_CTX_set1_id() for further info. If I<algor1> or I<algor2> are not
NULL then they are set to the AlgorithmIdentifier that corresponds to the
combination of signature algorithm and digest algorithm for the signature
operation of the I<pkey>.

ASN1_item_sign() is similar to ASN1_item_sign_ex() but uses default values of
NULL for the I<id>, I<libctx> and I<propq>.

ASN1_item_sign_ctx() is similiar to ASN1_item_sign() but uses the parameters
contained in digest context I<ctx>.

ASN1_item_verify_ex() is used to verify the signature I<signature> of internal
data I<data> using the public key I<pkey> and algorithm identifier I<alg>.
The data that is verified is formed by taking the data object in I<data> and
converting it to der format using the ASN.1 structure I<it>.
The B<OSSL_LIB_CTX> specified in I<libctx> and the property query string
specified in I<props> are used when searching for algorithms in providers.
The optional parameter I<id> can be NULL, but can be set for special key types.
See EVP_PKEY_CTX_set1_id() for further info.

ASN1_item_verify() is similar to ASN1_item_verify_ex() but uses default values of
NULL for the I<id>, I<libctx> and I<propq>.

ASN1_item_verify_ctx() is similiar to ASN1_item_verify() but uses the parameters
contained in digest context I<ctx>.


=head1 RETURN VALUES

All sign functions return the size of the signature in bytes for success and
zero for failure.

All verify functions return 1 if the signature is valid and 0 if the signature
check fails. If the signature could not be checked at all because it was
ill-formed or some other error occurred then -1 is returned.

=head1 EXAMPLES

In the following example an 'MyObject' object is signed using the key contained
in an md_ctx. The signature is written to MyObject.signature.

 #include <openssl/x509.h>

 /* An object used to store the ASN1 data fields to sign */
 typedef struct MySignObject_st
 {
     ASN1_INTEGER version;
     X509_ALGOR sig_alg;
 } MySignObject;

 /*
  * A higher level object containing the ASN1 fields, signature alg and
  * output signature.
  */
 typedef struct MyObject_st
 {
     MySignObject info;
     X509_ALGOR sig_alg;
     ASN1_BIT_STRING signature;
 } MyObject;

 ASN1_SEQUENCE_cb(MySignObject, NULL) = {
     ASN1_EMBED(MySignObject, version, ASN1_INTEGER),
     ASN1_EMBED(MySignObject, sig_alg, X509_ALGOR),
 } static_ASN1_SEQUENCE_END_cb(MySignObject, MySignObject)

 static int test_asn1_item_sign(MyObject *obj, EVP_PKEY *pkey, EVP_MD *md)
 {
     EVP_PKEY *pkey = NULL;
     EVP_PKEY_CTX *gctx = EVP_PKEY_CTX_new_from_name(NULL, "EC", NULL);

     /* 'it' contains the mapping between ASN.1 data and an object MySignObject */
     const ASN1_ITEM *it = ASN1_ITEM_rptr(MySignObject);
     EVP_MD_CTX *mdctx = EVP_MD_CTX_new();

     memset(obj, 0, sizeof(*obj));
     EVP_DigestSignInit(mdctx, NULL, md, NULL, pkey);
     /*
      * obj->info is the 'MySignObject' object that will be
      * converted into DER data and then signed.
      * obj->signature will contain the output signature.
      * obj->sig_alg is filled with the private key's signing algorithm id.
      * obj->info.sig_alg is another copy of the signing algorithm id that sits
      * within the MyObject object.
      */
     return ASN1_item_sign_ctx(it, &obj->sig_alg, &obj->info.sig_alg,
                               &obj->signature, &obj->info, mdctx);
 }

=head1 SEE ALSO

L<X509_sign(3)>,
L<X509_verify(3)>

=head1 HISTORY

ASN1_item_sign_ex() and ASN1_item_verify_ex() were added in OpenSSL 3.0.

=head1 COPYRIGHT

Copyright 2020 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
