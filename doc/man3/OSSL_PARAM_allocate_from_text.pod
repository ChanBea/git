=pod

=head1 NAME

OSSL_PARAM_parse_locate_const, OSSL_PARAM_allocate_from_text
- OSSL_PARAM construction utilities

=head1 SYNOPSIS

 #include <openssl/params.h>

 const OSSL_PARAM *OSSL_PARAM_parse_locate_const(const OSSL_PARAM *params,
                                                 const char *key,
                                                 int *flags);
 int OSSL_PARAM_allocate_from_text(OSSL_PARAM *to,
                                   const OSSL_PARAM *template,
                                   const char *value, size_t value_n,
                                   int flags);

=head1 DESCRIPTION

With OpenSSL before version 3.0, parameters were passed down to or
retrieved from algorithm implementations via control functions.
Some of these control functions existed in variants that took string
parameters, for example L<EVP_PKEY_CTX_ctrl_str(3)>.

OpenSSL 3.0 introduces a new mechanism to do the same thing with an
array of parameters that contain name, value, value type and value
size (see L<OSSL_PARAM(3)> for more information).

OSSL_PARAM_parse_locate_const() works like L<OSSL_PARAM_locate_const(3)>,
but will additionally parse the I<key> string and set flags in I<*flags>
according to what it found.  The flags must be initialized with zero by
the caller.  The returned B<OSSL_PARAM> pointer can be used as a template
for OSSL_PARAM_construct_from_text() and OSSL_PARAM_allocate_from_text().

OSSL_PARAM_allocate_from_text() builds the B<OSSL_PARAM> item passed as
I<to> by parsing I<value_n> bytes of I<value> according to the data type
from I<template> and the given I<flags>.
The I<flags> should be the value given back by OSSL_PARAM_parse_locate_const(),
or zero.
The data for I<to> gets allocated with L<OPENSSL_zalloc(3)> and must be
freed by the caller when it's not useful any more, using L<OPENSSL_free(3)>.

=head2 Details on key parsing

OSSL_PARAM_parse_locate_const() parses the I<key> for indicators that the
value may come in a non-default form.  This affects the I<*flags> as well
as what key is looked up in the descriptor B<OSSL_PARAM> array I<params>.

The following is recognised:

=over 4

=item The key starts with "hex"

This indicates that the I<value> is hex-encoded.  The rest of the I<key>
string will be used to locate the corresponding B<OSSL_PARAM>, so for
example, if the I<key> is "hexsalt", the key that will be looked up in the
B<OSSL_PARAM> array is "salt".

This affects how OSSL_PARAM_construct_from_text() and
OSSL_PARAM_allocate_from_text() parse the I<value> for I<template> types
B<OSSL_PARAM_INTEGER>, B<OSSL_PARAM_UNSIGNED_INTEGER>, and
B<OSSL_PARAM_OCTET_STRING>.

=back

=head1 RETURN VALUES

OSSL_PARAM_allocate_from_text() returns 1 on success, and 0 on error.

=head1 NOTES

The parameter descriptor array given to OSSL_PARAM_parse_locate_const()
comes from functions dedicated to return them.
The following B<OSSL_PARAM> attributes are used:

=over 4

=item I<key>

=item I<data>

=item I<data_size>

=back

All other attributes are ignored.

The I<data_size> attribute can be zero, meaning that the parameter it
describes expects arbitrary length data.

=head1 EXAMPLES

Code that looked like this:

  int mac_ctrl_string(EVP_PKEY_CTX *ctx, const char *value)
  {
      int rv;
      char *stmp, *vtmp = NULL;

      stmp = OPENSSL_strdup(value);
      if (stmp == NULL)
          return -1;
      vtmp = strchr(stmp, ':');
      if (vtmp != NULL)
          *vtmp++ = '\0';
      rv = EVP_MAC_ctrl_str(ctx, stmp, vtmp);
      OPENSSL_free(stmp);
      return rv;
  }

  ...


  for (i = 0; i < sk_OPENSSL_STRING_num(macopts); i++) {
      char *macopt = sk_OPENSSL_STRING_value(macopts, i);

      if (pkey_ctrl_string(mac_ctx, macopt) <= 0) {
          BIO_printf(bio_err,
                     "MAC parameter error \"%s\"\n", macopt);
          ERR_print_errors(bio_err);
          goto mac_end;
      }
  }

Can be written like this instead:

  OSSL_PARAM *params =
      OPENSSL_zalloc(sizeof(*params)
                     * (sk_OPENSSL_STRING_num(opts) + 1));
  const OSSL_PARAM *paramdefs = EVP_MAC_settable_ctx_params(mac);
  size_t params_n;
  char *opt = "<unknown>";

  for (params_n = 0; params_n < (size_t)sk_OPENSSL_STRING_num(opts);
       params_n++) {
      const OSSL_PARAM *tmpl;
      char *stmp, *vtmp = NULL;
      int tflags = 0;

      opt = sk_OPENSSL_STRING_value(opts, (int)params_n);
      if ((stmp = OPENSSL_strdup(opt)) == NULL
              || (vtmp = strchr(stmp, ':')) == NULL)
          goto err;

      *vtmp++ = '\0';

      tmpl = OSSL_PARAM_parse_locate_const(paramdefs, stmp, &tflags);
      if (tmpl == NULL
          || !OSSL_PARAM_allocate_from_text(&params[params_n],
                                            vtmp, strlen(vtmp), tflags))
          goto err;
  }
  params[params_n] = OSSL_PARAM_construct_end();
  if (!EVP_MAC_CTX_set_params(ctx, params))
      goto err;
  while (params_n-- > 0)
      OPENSSL_free(params[params_n].data);
  OPENSSL_free(params);
  /* ... */
  return;

 err:
  BIO_printf(bio_err, "MAC parameter error '%s'\n", opt);
  ERR_print_errors(bio_err);


=head1 SEE ALSO

L<OSSL_PARAM(3)>, L<OSSL_PARAM_int(3)>

=head1 COPYRIGHT

Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
