=pod

=head1 NAME

crypto - OpenSSL cryptographic library

=head1 SYNOPSIS

See the individual manual pages for details.

=head1 DESCRIPTION

The OpenSSL crypto library (C<libcrypto>) implements a wide range of
cryptographic algorithms used in various Internet standards. The services
provided by this library are used by the OpenSSL implementations of TLS and
CMS, and they have also been used to implement many other third party products
and protocols.

The functionality includes symmetric encryption, public key cryptography, key
agreement, certificate handling, cryptographic hash functions, cryptographic
pseudo-random number generators, message authentication codes (MACs), key
derivation functions (KDFs), and various utilities.

=head2 Algorithms

Cryptographic primitives such as the SHA256 digest, or AES encryption are
referred to in OpenSSL as "algorithms". Each algorithm may have multiple
implementations available for use. For example the RSA algorithm is available as
a "default" implementation suitable for general use, and a "fips" implementation
which has been validated to FIPS standards for situations where that is
important. It is also possible that a third party could add additional
implementations such as in a hardware security module (HSM).

=head2 Operations

Different algorithms can be grouped together by their purpose. For example there
are algorithms for encryption, and different algorithms for digesting data.
These different groups are known as "operations" in OpenSSL. Each operation
has a different set of functions associated with it. For example to perform an
encryption operation using AES (or any other encryption algorithm) you would use
the encryption functions detailed on the L<EVP_EncryptInit(3)> page. Or to
perform a digest operation using SHA256 then you would use the digesting
functions on the L<EVP_DigestInit(3)> page.

=head2 Providers

A provider in OpenSSL is a component that collects together algorithm
implementations. In order to use an algorithm you must have at least one
provider loaded that contains an implementation of it. OpenSSL comes with a
number of providers and they may also be obtained from third parties. If you
don't load a provider explicitly (either in program code or via config) then the
OpenSSL built-in "default" provider will be automatically loaded.
For more information see L</OPENSSL PROVIDERS>.


confidentiality, integrity, and authentication, and non-repudiation


=head2 Hash Function (Message Digest)

Given any input message (of any size), a Hash Function produces a fixed size
output (hash) value as a result.

A Hash function exhibits the following properties:
    It is quick to create a hash value for any given message.
    A Hash function is deterministic.
    It is computationally infeasible to calculate a message from any given hash (i.e. the function is one-way)
    It is infeasible to modify a message without also modifying the hash value
    It is infeasible to find two messages that result in the same hash.
    Small changes to an input message result in significant changes to the out hash (avalanche effect).

The OpenSSL library supports a wide number of different hash functions including
L<EVP_MD-SHA2(7)>, L<EVP_MD-SHA3(7)>, L<EVP_MD-SHAKE(7)>, L<EVP_MD-KECCAK(7)> and L<EVP_MD-SM3(7)>.

See L<OSSL_PROVIDER-default(7)/Hashing Algorithms // Message Digests>
and L<OSSL_PROVIDER-FIPS(7)/Hashing Algorithms // Message Digests> for a
list of Hash Functions supported by the OpenSSL L</Providers>.

See L</EVP_DigestInit(3)/EXAMPLES> for an example of how to digest a message.
See also the digest demos at https://github.com/openssl/openssl/tree/master/demos/digest.

Hash Functions are used by other algorithms such as L</Message Authentication Code (MAC)> and L</Digital Signatures>.

=head2 Symmetric encryption

Symmetric-key algorithms use a single shared secret key that is used for both encryption of
plaintext and decryption of ciphertext.
The requirement that both parties have access to the secret key is one of the main drawbacks of symmetric-key encryption,
in comparison to L</Public key cryptography (Asymmetric Cryptography)>
Symmetric-key encryption algorithms are usually better for bulk encryption.
since they have a smaller key size, which means less storage space and faster transmission.
Due to this, asymmetric-key encryption is often used to exchange the secret key for symmetric-key encryption.

In order to prevent brute force attacks, secret key lengths of 128 bits are commonly used.


See L<EVP_EncryptInit(3)>

For a list of available ciphers (such as L<EVP_CIPHER-AES(7)>) see L<OSSL_PROVIDER-default(7)/Symmetric Ciphers>
and L<OSSL_PROVIDER-FIPS(7)/Symmetric Ciphers>.

=head2 Public key cryptography (Asymmetric Cryptography)

Public-key cryptography use pairs of related keys (a key pair) to perform cryptographic operations.
Each key pair consists of a public key which can be openly distributed, and a corresponding private
key which must be kept secret.
Key pairs are generated using cryptographic algorithms based on mathematical problems using one-way functions.
Public key algorithms are fundamental security primitives in modern cryptosystems,
including applications and protocols which offer assurance of the confidentiality, authenticity and non-repudiability of
electronic communications and data storage. They underpin numerous Internet standards, such as Transport Layer Security (TLS), and SSH.

Some public key algorithms provide key distribution and secrecy (e.g, Diffie-Hellman key exchange),
some provide digital signatures (e.g, Digital Signature Algorithm), and some provide both (e.g. RSA).

Asymmetric encryption is much slower than using L</Symmetric encryption>, so many cryptosystems such as TLS and SSH
use both (by using asymmetric encryption to securely exchange a secret symmetric key which is then used for
symmetric encryption.)

In order to prevent brute force attacks, secret key lengths of 2048 bits (for public-key algorithms such as RSA, DSA & DH) are commonly used.

In OpenSSL an L<EVP_PKEY(7)> object is used to store the key pair.

The public key types in OpenSSL are:

=over 4

=item Elliptic Curve Cryptography (ECC)

ECC allows smaller keys compared to non-EC cryptography to provide equivalent security strength.
i.e. A 256 bit EC key provides 128 bit of security strength.

L<EVP_PKEY-EC(7)> is used for L</Key Agreement> and L</Digital Signatures>.
L<EVP_PKEY-SM2(7)>

The edwards curves L<EVP_PKEY-X25519(7)> and L<EVP_PKEY-X448(7)> are used for L</Key Agreement>.
The edwards curves L<EVP_PKEY-ED25519(7)>, L<EVP_PKEY-ED448(7)> are used for L</Digital Signatures>.

=item RSA

See L<EVP_PKEY-RSA(7)> which is used by 
L</Key Encapsulation Mechanism (KEM)>,
L</Digital Signatures> and
L</Asymmetric Key Wrapping>.

=item Diffie Hellman (DH)

See L<EVP_PKEY-DH(7)> and
L</Key Agreement>

=item Digital Signature Algorithm (DSA)

See L<EVP_PKEY-DSA(7)> and
L</Digital Signatures>

=back

DH and DSA keys use Finite Field Cryptography, See L<EVP_PKEY-FFC(7)>.

=head3 Domain parameters

Domain parameters are normally public values that can be shared by multiple parties,
and are used for key generation, key agreement and digital signatures.
They are used by DSA, DH and EC.

For more information see:
L<EVP_PKEY-DSA(7)/DSA parameters>,
L<EVP_PKEY-DH(7)/DH and DHX domain parameters> and
L<EVP_PKEY-EC(7)/Common EC parameters>

=head3 Asymmetric Key Generation

Key generation is the process of generating key pairs.
In many cases keys are randomly generated using a pseudo-random number generator (PRNG).

Generation in cryptography

Modern cryptographic systems include symmetric-key algorithms (such as DES and AES) and public-key algorithms (such as RSA). 


Public-key algorithms use a public key and a private key. The public key is made available to anyone (often by means of a digital certificate). A sender encrypts data with the receiver's public key; only the holder of the private key can decrypt this data.

Since public-key algorithms tend to be much slower than symmetric-key algorithms, modern systems such as TLS and SSH use a combination of the two: one party receives the other's public key, and encrypts a small piece of data (either a symmetric key or some data used to generate it). The remainder of the conversation uses a (typically faster) symmetric-key algorithm for encryption.

Computer cryptography uses integers for keys.

A PRNG is a computer algorithm that produces data that appears random under analysis.
PRNGs that use system entropy to seed data generally produce better results, since this makes the initial conditions of the PRNG much more difficult for an attacker to guess. Another way to generate randomness is to utilize information outside the system. Veracrypt (a disk encryption software) utilizes user mouse movements to generate unique seeds, in which users are encouraged to move their mouse sporadically. In other situations, the key is derived deterministically using a passphrase and a key derivation function.

Many modern protocols are designed to have forward secrecy, which requires generating a fresh new shared key for each session.

Classic cryptosystems invariably generate two identical keys at one end of the communication link and somehow transport one of the keys to the other end of the link. However, it simplifies key management to use Diffie–Hellman key exchange instead.



Demos for keygen are located in https://github.com/openssl/openssl/tree/master/demos/pkey

=head3 Asymmetric Encryption

In a public-key encryption system, anyone with a public key can encrypt a message,
yielding a ciphertext, but only those who know the corresponding private key can decrypt the ciphertext to obtain the original message.

They use two keys, one for encryption of messages and the other one during decryption.

See L<EVP_PKEY_encrypt(3)> as well as L<EVP_ASYM_CIPHER-RSA(7)> and L<EVP_ASYM_CIPHER-SM2(7)>.
A demo can be found at https://github.com/openssl/openssl/blob/master/demos/encrypt/rsa_encrypt.c.

=head3 Digital Signatures

In a digital signature system, a sender can use a private key together with an arbitrary message to create a signature.
Anyone with the corresponding public key can verify whether the signature matches the message, but a forger who doesn't know the
private key can't find any message/signature pair that will pass verification with the public key.

Digital signatures are used to detect unauthorized modifications to data and to authenticate the identity of a signer.
In addition, the recipient of signed data can use a digital signature as evidence in demonstrating to a third party that the signature was,
in fact, generated by the claimed signer (non-repudiation).

A L</Hash Function> is used in the signature generation process to obtain a condensed version of the
data to be signed (TBS). The message digest is input to the digital signature algorithm to generate
the digital signature.

See L<EVP_DigestSignInit(3)>, L<EVP_DigestVerifyInit(3)> as well as
L<EVP_SIGNATURE-ECDSA(7)>,
L<EVP_SIGNATURE-ED25519(7)>,
L<EVP_SIGNATURE-ED448(7)>,
L<EVP_SIGNATURE-RSA(7)> and
L<EVP_SIGNATURE-DSA(7)>.

See the Signature demos at L<https://github.com/openssl/openssl/tree/master/demos/signature>.

=head2 Key Agreement Schemes (KAS)

https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Br2.pdf


=head3 Key Agreement

A shared secret is derived by two (or more) parties

For ECDH L<EVP_KEYEXCH-ECDH(7)> "ecdh-cofactor-mode" 
See L<EVP_KEYEXCH-ECDH(7)>, L<EVP_KEYEXCH-DH(7)> and L<EVP_KEYEXCH-X25519(7)>

See the key exchange demo at https://github.com/openssl/openssl/tree/master/demos/keyexch

=head3 Key Wrapping & Key Transportation

Key transportation is defined as the secure transportation of a key.
Key wrapping can be used to securely transport secret keys over an insecure channel.
One party (the sender) selects a value for the secret keying material and then securely
distributes that value to another party (the receiver).
The secret key is encapsulated (encrypted) by using either a symmetric key or asymmetric key pair.
The key used to encapsulate the secret key is called a Key Encryption Key (KEK),
the encapsulated secret key in called the Data Encryption Key (DEK).

OpenSSL contains the following Key Wrapping Algorithms:

=head4 Symmetric Key Wrapping

The Advanced Encryption Standard (AES) Key Wrap algorithm is defined in
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf
See L<EVP_CIPHER-AES(7)>.

This consists of AES Key Wrap (KW) mode which has algorithms names
"AES-128-WRAP", "AES-192-WRAP", "AES-256-WRAP",

and the AES Key Wrap With Padding (KWP) mode which has algorithm names
"AES-128-WRAP-PAD", "AES-192-WRAP-PAD", "AES-256-WRAP-PAD",

There are also inverse ciphers which use AES decryption for wrapping,
and AES encryption for unwrapping. The algorithms names are:
"AES-128-WRAP-INV", "AES-192-WRAP-INV", "AES-256-WRAP-INV",
"AES-128-WRAP-PAD-INV", "AES-192-WRAP-PAD-INV" and "AES-256-WRAP-PAD-INV".

An AES Key wrapping demo can be found here
https://github.com/openssl/openssl/tree/master/demos/cipher/aeskeywrap.c

=head4 Asymmetric Key Wrapping

Key-Transport Using RSA-OAEP is defined in
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Br2.pdf#%5B%7B%22num%22%3A290%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C710%2C0%5D

See L<EVP_ASYM_CIPHER-RSA(7)> with the pad_mode of "OAEP"

A RSA OEAP demo can be found here
https://github.com/openssl/openssl/tree/master/demos/encrypt/rsa_encrypt.c


=head2 Public Key Certificates

A certificate is an electronic document that includes the following information:

=over 4

=item Public key

See L</Public key cryptography (Asymmetric Cryptography)>

=item Subject

Identity of the owner which is typically a person or organization, computer or other device,

=item Issuer

The entity that issued the certificate.

=item Validity period

The NotBefore and NotAfter fields specify the time range in which it is valid to use the certificate.

=item Optional Extensions

Extensions indicate how the certificate should be used, which includes

Basic Constraints, Key Usage and Extended Key Usage,

=item L</Digital signature>

The digital signature of an entity that has verified the certificate's contents (Issuer).

=back

Certificates are used to prove the validity of a public key.
If the signature is valid, and the software examining the certificate trusts the issuer,
then it can use that key to communicate securely with the certificate's subject. 

In a typical public-key infrastructure (PKI) scheme, the certificate Issuer is a certificate authority (CA).
The most common format for public key certificates is defined by L<x509(7)> as defined by RFC 5280.

For a certificate chain, The Issuer of each certificate (except the last one) matches the Subject of the next certificate in the list
Each certificate (except the last one) is signed by the secret key corresponding to the next certificate in the chain
(i.e. the signature of one certificate can be verified using the public key contained in the following certificate)
The last certificate in the list is a trust anchor: a certificate that you trust because it was delivered to you by some trustworthy procedure

A certificate can also be self signed.

=head3 Key Validation

Prior to, or during a key-establishment transactions, the parties involved
must obtain assurances about the validity of the key(s) being used.
See https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf
for more information.

The OpenSSL FIPS provider implements these assurances using L<EVP_PKEY_check(3)>,
L<EVP_PKEY_param_check(3)>, L<EVP_PKEY_param_check_quick(3)>,
L<EVP_PKEY_public_check(3)>, L<EVP_PKEY_public_check_quick(3)>,
L<EVP_PKEY_private_check(3)>, and L<EVP_PKEY_pairwise_check(3)>.

The OpenSSL default provider may do simpler checks for backwards compatibility.

See also L<EVP_PKEY-DH(7)/DH key validation>, L<EVP_PKEY-DSA(7)/DSA key validation>,
L<EVP_PKEY-EC(7)/EC key validation> and L<EVP_PKEY-RSA(7)/RSA key validation>.

Key Validation is implemented by a L</Key Manager>.

=head2 Key Manager

OpenSSL L</Providers> contain Key managers for each different type of Asymmetric key.
Each OpenSSL Key manager supports methods to handle L</Key generation>, and L</Key validation>,
as well as the ability to import keys into a provider, and export keys from a provider.

For a list of Key managers see:
L<OSSL_PROVIDER-default(7)/Asymmetric Key Management> and
L<OSSL_PROVIDER-FIPS(7)/Asymmetric Key Management>.

=head2 Key Encapsulation Mechanism (KEM)

A Key Encapsulation Mechanism can be used to securely transmit symmetric key material using asymmetric (public-key) algorithms.

See L<EVP_PKEY_encapsulate(3)> and L<EVP_PKEY_decapsulate(3)>.

L<EVP_KEM-RSA(7)> supports RSA Secret Value Encapsulation (RSASVE) as defined in
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Br2.pdf#%5B%7B%22num%22%3A213%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C70%2C404%2C0%5D
L<EVP_KEM-EC(7)> and L<EVP_KEM-X25519(7)> support DHKEM which is used by
L</Hybrid Public Key Encryption (HPKE)> as defined by https://www.rfc-editor.org/rfc/rfc9180.pdf#name-key-encapsulation-mechanism


=head2 Hybrid Public Key Encryption (HPKE)

A hybrid cryptosystem is one which combines the convenience of a public-key cryptosystem with the efficiency of a symmetric-key cryptosystem.
Hybrid Public Key Encryption (HPKE, published as https://www.rfc-editor.org/rfc/rfc9180.pdf) is a modern standard for generic hybrid encryption.
HPKE is used within multiple IETF protocols, including MTLS and TLS Encrypted Hello. 
HPKE works for any combination of an asymmetric KEM, key derivation function (KDF), and authenticated encryption with additional data (AEAD)
encryption function. 

See L<OSSL_HPKE_CTX_new(3)>.

pseudo-random number generator
(CSPRNG).

=head2 Deterministic Random Bit Generators (DRBG) 

Random Numbers are required for key generation, nonces and salts.
See L<RAND(7)> for further information.


=head2 Message Authentication Code (MAC)

A family of secret-key cryptographic algorithms acting on input data of arbitrary length to produce an output value of a specified length
(called the MAC of the input data). A MAC (or tag) can be employed to provide authentication of the origin of data and/or data-integrity protection.
MAC's are used by other algoriths such as L</Key Derivation Function (KDF)> and L</Deterministic Random Bit Generators (DRBG)>.

See L<EVP_MAC(3)>

See the MAC demos at https://github.com/openssl/openssl/tree/master/demos/mac.

See L<OSSL_PROVIDER-default(7)/Message Authentication Code (MAC)>
and L<OSSL_PROVIDER-FIPS(7)/Message Authentication Code (MAC)> for a list of Hash Functions
supported by the OpenSSL L</Providers>.

See L<migration_guide(7)/Message Authentication Code API (EVP_MAC)> for information related to the old API used.

=head2 Key Derivation Function (KDF)

Key derivation is the process of deriving one or more secret keys from input values
such as a password or key material. Several key derivation algorithms have
been standardized, and they are usually referred to as Key Derivation Functions (KDFs).
KDF's are deterministic (see L<openssl-glossary(7)>).

See L<EVP_KDF(3)> for more information related to OpenSSL KDF's.

L<EVP_KDF-SCRYPT(7)> and  L<EVP_KDF-PBKDF2(7)> are examples of Password based KDF's 
L<EVP_KDF-HKDF(7)>, L<EVP_KDF-SS(7)>, L<EVP_KDF-KB(7)> and L<EVP_KDF-SSHKDF(7)> are examples
of non Password based KDF's.

For a list of KDF's supported by the OpenSSL L</Providers> See:
L<OSSL_PROVIDER-default(7)/Key Derivation Function (KDF)>,
L<OSSL_PROVIDER-FIPS(7)/Key Derivation Function (KDF)> and
L<OSSL_PROVIDER-legacy(7)/Key Derivation Function (KDF)>

KDF demos can be found at https://github.com/openssl/openssl/tree/master/demos/kdf

If compatibility with OpenSSL 1.1.1 is required then a limited set of KDFs can be used via L<EVP_PKEY_derive(3)>.

=head2 Library contexts

A library context can be thought of as a "scope" within which configuration
options take effect. When a provider is loaded, it is only loaded within the
scope of a given library context. In this way it is possible for different
components of a complex application to each use a different library context and
have different providers loaded with different configuration settings.

If an application does not explicitly create a library context then the
"default" library context will be used.

Library contexts are represented by the B<OSSL_LIB_CTX> type. Many OpenSSL API
functions take a library context as a parameter. Applications can always pass
B<NULL> for this parameter to just use the default library context.

The default library context is automatically created the first time it is
needed. This will automatically load any available configuration file and will
initialise OpenSSL for use. Unlike in earlier versions of OpenSSL (prior to
1.1.0) no explicit initialisation steps need to be taken.

Similarly when the application exits the default library context is
automatically destroyed. No explicit de-initialisation steps need to be taken.

See L<OSSL_LIB_CTX(3)> for more information about library contexts.
See also L</ALGORITHM FETCHING>.

=head2 Multi-threaded applications

As long as OpenSSL has been built with support for threads (the default case
on most platforms) then most OpenSSL I<functions> are thread-safe in the sense
that it is safe to call the same function from multiple threads at the same
time. However most OpenSSL I<data structures> are not thread-safe. For example
the L<BIO_write(3)> and L<BIO_read(3)> functions are thread safe. However it
would not be thread safe to call BIO_write() from one thread while calling
BIO_read() in another where both functions are passed the same B<BIO> object
since both of them may attempt to make changes to the same B<BIO> object.

There are exceptions to these rules. A small number of functions are not thread
safe at all. Where this is the case this restriction should be noted in the
documentation for the function. Similarly some data structures may be partially
or fully thread safe. For example it is safe to use an B<OSSL_LIB_CTX> in
multiple threads.

See L<openssl-threads(7)> for a more detailed discussion on OpenSSL threading
support.

=head1 ALGORITHM FETCHING

In order to use an algorithm an implementation for it must first be "fetched".
Fetching is the process of looking through the available implementations,
applying selection criteria (via a property query string), and finally choosing
the implementation that will be used.

Two types of fetching are supported by OpenSSL - explicit fetching and implicit
fetching.

=head2 Property query strings

When fetching an algorithm it is possible to specify a property query string to
guide the selection process. For example a property query string of
"provider=default" could be used to force the selection to only consider
algorithm implementations in the default provider.

Property query strings can be specified explicitly as an argument to a function.
It is also possible to specify a default property query string for the whole
library context using the L<EVP_set_default_properties(3)> function. Where both
default properties and function specific properties are specified then they are
combined. Function specific properties will override default properties where
there is a conflict.

See L<property(7)> for more information about properties.

=head2 Explicit fetching

Users of the OpenSSL libraries never query a provider directly for an algorithm
implementation. Instead, the diverse OpenSSL APIs often have explicit fetching
functions that do the work, and they return an appropriate algorithm object back
to the user. These functions usually have the name C<APINAME_fetch>, where
C<APINAME> is the name of the operation. For example L<EVP_MD_fetch(3)> can
be used to explicitly fetch a digest algorithm implementation. The user is
responsible for freeing the object returned from the C<APINAME_fetch> function
using C<APINAME_free> when it is no longer needed.

These fetching functions follow a fairly common pattern, where three
arguments are passed:

=over 4

=item The library context

See L<OSSL_LIB_CTX(3)> for a more detailed description.
This may be NULL to signify the default (global) library context, or a
context created by the user. Only providers loaded in this library context (see
L<OSSL_PROVIDER_load(3)>) will be considered by the fetching function. In case
no provider has been loaded in this library context then the default provider
will be loaded as a fallback (see L<OSSL_PROVIDER-default(7)>).

=item An identifier

For all currently implemented fetching functions this is the algorithm name.

=item A property query string

The property query string used to guide selection of the algorithm
implementation.

=back

The algorithm implementation that is fetched can then be used with other diverse
functions that use them. For example the L<EVP_DigestInit_ex(3)> function takes
as a parameter an B<EVP_MD> object which may have been returned from an earlier
call to L<EVP_MD_fetch(3)>.

=head2 Implicit fetch

OpenSSL has a number of functions that return an algorithm object with no
associated implementation, such as L<EVP_sha256(3)>, L<EVP_aes_128_cbc(3)>,
L<EVP_get_cipherbyname(3)> or L<EVP_get_digestbyname(3)>. These are present for
compatibility with OpenSSL before version 3.0 where explicit fetching was not
available.

When they are used with functions like L<EVP_DigestInit_ex(3)> or
L<EVP_CipherInit_ex(3)>, the actual implementation to be used is
fetched implicitly using default search criteria.

In some cases implicit fetching can also occur when a NULL algorithm parameter
is supplied. In this case an algorithm implementation is implicitly fetched
using default search criteria and an algorithm name that is consistent with
the context in which it is being used.

Functions that revolve around B<EVP_PKEY_CTX> and L<EVP_PKEY(3)>, such as
L<EVP_DigestSignInit(3)> and friends, all fetch the implementations
implicitly.  Because these functions involve both an operation type (such as
L<EVP_SIGNATURE(3)>) and an L<EVP_KEYMGMT(3)> for the L<EVP_PKEY(3)>, they try
the following:

=over 4

=item 1.

Fetch the operation type implementation from any provider given a library
context and property string stored in the B<EVP_PKEY_CTX>.

If the provider of the operation type implementation is different from the
provider of the L<EVP_PKEY(3)>'s L<EVP_KEYMGMT(3)> implementation, try to
fetch a L<EVP_KEYMGMT(3)> implementation in the same provider as the operation
type implementation and export the L<EVP_PKEY(3)> to it (effectively making a
temporary copy of the original key).

If anything in this step fails, the next step is used as a fallback.

=item 2.

As a fallback, try to fetch the operation type implementation from the same
provider as the original L<EVP_PKEY(3)>'s L<EVP_KEYMGMT(3)>, still using the
property string from the B<EVP_PKEY_CTX>.

=back

=head1 FETCHING EXAMPLES

The following section provides a series of examples of fetching algorithm
implementations.

Fetch any available implementation of SHA2-256 in the default context. Note
that some algorithms have aliases. So "SHA256" and "SHA2-256" are synonymous:

 EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", NULL);
 ...
 EVP_MD_free(md);

Fetch any available implementation of AES-128-CBC in the default context:

 EVP_CIPHER *cipher = EVP_CIPHER_fetch(NULL, "AES-128-CBC", NULL);
 ...
 EVP_CIPHER_free(cipher);

Fetch an implementation of SHA2-256 from the default provider in the default
context:

 EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider=default");
 ...
 EVP_MD_free(md);

Fetch an implementation of SHA2-256 that is not from the default provider in the
default context:

 EVP_MD *md = EVP_MD_fetch(NULL, "SHA2-256", "provider!=default");
 ...
 EVP_MD_free(md);

Fetch an implementation of SHA2-256 from the default provider in the specified
context:

 EVP_MD *md = EVP_MD_fetch(ctx, "SHA2-256", "provider=default");
 ...
 EVP_MD_free(md);

Load the legacy provider into the default context and then fetch an
implementation of WHIRLPOOL from it:

 /* This only needs to be done once - usually at application start up */
 OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, "legacy");

 EVP_MD *md = EVP_MD_fetch(NULL, "WHIRLPOOL", "provider=legacy");
 ...
 EVP_MD_free(md);

Note that in the above example the property string "provider=legacy" is optional
since, assuming no other providers have been loaded, the only implementation of
the "whirlpool" algorithm is in the "legacy" provider. Also note that the
default provider should be explicitly loaded if it is required in addition to
other providers:

 /* This only needs to be done once - usually at application start up */
 OSSL_PROVIDER *legacy = OSSL_PROVIDER_load(NULL, "legacy");
 OSSL_PROVIDER *default = OSSL_PROVIDER_load(NULL, "default");

 EVP_MD *md_whirlpool = EVP_MD_fetch(NULL, "whirlpool", NULL);
 EVP_MD *md_sha256 = EVP_MD_fetch(NULL, "SHA2-256", NULL);
 ...
 EVP_MD_free(md_whirlpool);
 EVP_MD_free(md_sha256);

=head1 OPENSSL PROVIDERS

OpenSSL comes with a set of providers.

The algorithms available in each of these providers may vary due to build time
configuration options. The L<openssl-list(1)> command can be used to list the
currently available algorithms.

The names of the algorithms shown from L<openssl-list(1)> can be used as an
algorithm identifier to the appropriate fetching function. Also see the provider
specific manual pages linked below for further details about using the
algorithms available in each of the providers.

As well as the OpenSSL providers third parties can also implement providers.
For information on writing a provider see L<provider(7)>.

=head2 Default provider

The default provider is built in as part of the F<libcrypto> library and
contains all of the most commonly used algorithm implementations. Should it be
needed (if other providers are loaded and offer implementations of the same
algorithms), the property query string "provider=default" can be used as a
search criterion for these implementations.  The default provider includes all
of the functionality in the base provider below.

If you don't load any providers at all then the "default" provider will be
automatically loaded. If you explicitly load any provider then the "default"
provider would also need to be explicitly loaded if it is required.

See L<OSSL_PROVIDER-default(7)>.

=head2 Base provider

The base provider is built in as part of the F<libcrypto> library and contains
algorithm implementations for encoding and decoding for OpenSSL keys.
Should it be needed (if other providers are loaded and offer
implementations of the same algorithms), the property query string
"provider=base" can be used as a search criterion for these implementations.
Some encoding and decoding algorithm implementations are not FIPS algorithm
implementations in themselves but support algorithms from the FIPS provider and
are allowed for use in "FIPS mode". The property query string "fips=yes" can be
used to select such algorithms.

See L<OSSL_PROVIDER-base(7)>.

=head2 FIPS provider

The FIPS provider is a dynamically loadable module, and must therefore
be loaded explicitly, either in code or through OpenSSL configuration
(see L<config(5)>). It contains algorithm implementations that have been
validated according to the FIPS 140-2 standard. Should it be needed (if other
providers are loaded and offer implementations of the same algorithms), the
property query string "provider=fips" can be used as a search criterion for
these implementations. All approved algorithm implementations in the FIPS
provider can also be selected with the property "fips=yes". The FIPS provider
may also contain non-approved algorithm implementations and these can be
selected with the property "fips=no".

See L<OSSL_PROVIDER-FIPS(7)> and L<fips_module(7)>.

=head2 Legacy provider

The legacy provider is a dynamically loadable module, and must therefore
be loaded explicitly, either in code or through OpenSSL configuration
(see L<config(5)>). It contains algorithm implementations that are considered
insecure, or are no longer in common use such as MD2 or RC4. Should it be needed
(if other providers are loaded and offer implementations of the same algorithms),
the property "provider=legacy" can be used as a search criterion for these
implementations.

See L<OSSL_PROVIDER-legacy(7)>.

=head2 Null provider

The null provider is built in as part of the F<libcrypto> library. It contains
no algorithms in it at all. When fetching algorithms the default provider will
be automatically loaded if no other provider has been explicitly loaded. To
prevent that from happening you can explicitly load the null provider.

See L<OSSL_PROVIDER-null(7)>.

=head1 USING ALGORITHMS IN APPLICATIONS

Cryptographic algorithms are made available to applications through use of the
"EVP" APIs. Each of the various operations such as encryption, digesting,
message authentication codes, etc., have a set of EVP function calls that can
be invoked to use them. See the L<evp(7)> page for further details.

Most of these follow a common pattern. A "context" object is first created. For
example for a digest operation you would use an B<EVP_MD_CTX>, and for an
encryption/decryption operation you would use an B<EVP_CIPHER_CTX>. The
operation is then initialised ready for use via an "init" function - optionally
passing in a set of parameters (using the B<OSSL_PARAM> type) to configure how
the operation should behave. Next data is fed into the operation in a series of
"update" calls. The operation is finalised using a "final" call which will
typically provide some kind of output. Finally the context is cleaned up and
freed.

The following shows a complete example for doing this process for digesting
data using SHA256. The process is similar for other operations such as
encryption/decryption, signatures, message authentication codes, etc.

 #include <stdio.h>
 #include <openssl/evp.h>
 #include <openssl/bio.h>
 #include <openssl/err.h>

 int main(void)
 {
     EVP_MD_CTX *ctx = NULL;
     EVP_MD *sha256 = NULL;
     const unsigned char msg[] = {
         0x00, 0x01, 0x02, 0x03
     };
     unsigned int len = 0;
     unsigned char *outdigest = NULL;
     int ret = 1;

     /* Create a context for the digest operation */
     ctx = EVP_MD_CTX_new();
     if (ctx == NULL)
         goto err;

     /*
      * Fetch the SHA256 algorithm implementation for doing the digest. We're
      * using the "default" library context here (first NULL parameter), and
      * we're not supplying any particular search criteria for our SHA256
      * implementation (second NULL parameter). Any SHA256 implementation will
      * do.
      */
     sha256 = EVP_MD_fetch(NULL, "SHA256", NULL);
     if (sha256 == NULL)
         goto err;

    /* Initialise the digest operation */
    if (!EVP_DigestInit_ex(ctx, sha256, NULL))
        goto err;

     /*
      * Pass the message to be digested. This can be passed in over multiple
      * EVP_DigestUpdate calls if necessary
      */
     if (!EVP_DigestUpdate(ctx, msg, sizeof(msg)))
         goto err;

     /* Allocate the output buffer */
     outdigest = OPENSSL_malloc(EVP_MD_get_size(sha256));
     if (outdigest == NULL)
         goto err;

     /* Now calculate the digest itself */
     if (!EVP_DigestFinal_ex(ctx, outdigest, &len))
         goto err;

     /* Print out the digest result */
     BIO_dump_fp(stdout, outdigest, len);

     ret = 0;

  err:
     /* Clean up all the resources we allocated */
     OPENSSL_free(outdigest);
     EVP_MD_free(sha256);
     EVP_MD_CTX_free(ctx);
     if (ret != 0)
        ERR_print_errors_fp(stderr);
     return ret;
 }

=head1 CONFIGURATION

By default OpenSSL will load a configuration file when it is first used. This
will set up various configuration settings within the default library context.
Applications that create their own library contexts may optionally configure
them with a config file using the L<OSSL_LIB_CTX_load_config(3)> function.

The configuration file can be used to automatically load providers and set up
default property query strings.

For information on the OpenSSL configuration file format see L<config(5)>.

=head1 ENCODING AND DECODING KEYS

Many algorithms require the use of a key. Keys can be generated dynamically
using the EVP APIs (for example see L<EVP_PKEY_Q_keygen(3)>). However it is often
necessary to save or load keys (or their associated parameters) to or from some
external format such as PEM or DER (see L<openssl-glossary(7)>). OpenSSL uses
encoders and decoders to perform this task.

Encoders and decoders are just algorithm implementations in the same way as
any other algorithm implementation in OpenSSL. They are implemented by
providers. The OpenSSL encoders and decoders are available in the default
provider. They are also duplicated in the base provider.

For information about encoders see L<OSSL_ENCODER_CTX_new_for_pkey(3)>. For
information about decoders see L<OSSL_DECODER_CTX_new_for_pkey(3)>.

=head1 LIBRARY CONVENTIONS

Many OpenSSL functions that "get" or "set" a value follow a naming convention
using the numbers B<0> and B<1>, i.e. "get0", "get1", "set0" and "set1". This
can also apply to some functions that "add" a value to an existing set, i.e.
"add0" and "add1".

For example the functions:

 int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
 int X509_add1_trust_object(X509 *x, const ASN1_OBJECT *obj);

In the B<0> version the ownership of the object is passed to (for an add or set)
or retained by (for a get) the parent object. For example after calling the
X509_CRL_add0_revoked() function above, ownership of the I<rev> object is passed
to the I<crl> object. Therefore, after calling this function I<rev> should not
be freed directly. It will be freed implicitly when I<crl> is freed.

In the B<1> version the ownership of the object is not passed to or retained by
the parent object. Instead a copy or "up ref" of the object is performed. So
after calling the X509_add1_trust_object() function above the application will
still be responsible for freeing the I<obj> value where appropriate.

=head1 SEE ALSO

L<openssl(1)>, L<ssl(7)>, L<evp(7)>, L<OSSL_LIB_CTX(3)>, L<openssl-threads(7)>,
L<property(7)>, L<OSSL_PROVIDER-default(7)>, L<OSSL_PROVIDER-base(7)>,
L<OSSL_PROVIDER-FIPS(7)>, L<OSSL_PROVIDER-legacy(7)>, L<OSSL_PROVIDER-null(7)>,
L<openssl-glossary(7)>, L<provider(7)>

=head1 COPYRIGHT

Copyright 2000-2022 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
