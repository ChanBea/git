=pod

=head1 NAME

openssl/core.h - OpenSSL Core types

=head1 SYNOPSIS

 #include <openssl/core.h>

=head1 DESCRIPTION

The <openssl/core.h> header file defines a number of public types that
are used to communicate between the OpenSSL libraries and
implementation providers.
These types are designed to minimise the need for intimate knowledge
of internal structures between the OpenSSL libraries and the providers.

The types are:

=over 4

=item C<OSSL_DISPATCH>

This type is a tuple of function identity and function pointer.
Arrays of this type are passed between the OpenSSL libraries and the
providers to describe what functionality one side provides to the
other.
Arrays of this type must be terminated with a tuple having function
identity zero and function pointer C<NULL>.

The available function identities and corresponding function
signatures are defined by L<openssl-core_numbers.h(7)>.

Any function identity not recognised by the recipient of this type
will be ignored.
This ensures that providers built with one OpenSSL version in mind
will work together with any other OpenSSL version that supports this
mechanism.

=item C<OSSL_ITEM>

This type is a tuple of integer and pointer.
It's a generic type used as a generic descriptor, its exact meaning
being defined by how it's used.
Arrays of this type are passed between the OpenSSL libraries and the
providers, and must be terminated with a tuple where the integer is
zero and the pointer C<NULL>.

=item C<OSSL_ALGORITHM>

This type is a tuple of an algorithm name (string), a property
definition (string) and a dispatch table (array of C<OSSL_DISPATCH>).
Arrays of this type are passed on demand from the providers to the
OpenSSL libraries to describe what algorithms the providers provide
implementations of, and with what properties.
Arrays of this type must be terminated with a tuple having function
identity zero and function pointer C<NULL>.

The algorithm names and property definitions are defined by the
providers.

=item C<OSSL_PARAM>

This type is a structure that allows passing arbitrary object data
between two parties that have no or very little shared knowledge about
their respective internal structures for that object. 
It's normally passed in arrays, where the array is terminated with an
element where all fields are zero (for non-pointers) or C<NULL> (for
pointers).

These arrays can be used both to pass parameter data to some function,
but can also be used to request data from some function.
For a request, this description talks about a requesting function that
provides the C<OSSL_PARAM> array, and a responding function that fills
in the buffers that the C<OSSL_PARAM> elements point at.

Regardless of the use, the array as well as any buffer space it points
to must be provided by the caller (the requesting function).

The fields of this structure are:

=over 4

=item C<key>

The identity of the parameter in the form of a string.

These identities are defined by the entity that provides these
parameters, i.e. names for parameters provided by the OpenSSL
libraries are defined by the libraries, and names for parameters
provided by providers are defined by those providers, except for the
pointer form of strings (see data type descriptions below)

=item C<buffer>

=item C<buffer_size>

C<buffer> is a pointer to the memory where the parameter data is or
shall be stored, and C<buffer_size> is its size in bytes.
The organization of the data depends on the parameter type and flag.

=item C<return_size>

When an array of C<OSSL_PARAM> is used to request data, the responding
function must set this field to indicate the actual size of the data
stored in memory pointed at by the C<buffer> pointer, or the needed
buffer size if the size indicated by C<buffer_size> is too small.

=item C<data_type>

=for comment It's still debated if this field should be present, or if
the type should always be implied by how it's used.  Either way, these
data types will have to be passed together with the names as an array
of OSSL_ITEM, for discovery purposes.

The C<data_type> is a value that describes the type and organization of
the data, and can be one of:

=over 4

=for comment XXXX FIX ME

=item C<OSSL_PARAM_INTEGER>

The parameter data is an integer (signed or unsigned) of arbitrary
length, organized in native form, i.e. most significant byte first on
Big-Endian systems, and least significant byte first on Little-Endian
systems.

=item C<OSSL_PARAM_REAL>

=for comment It's still debated if we need this or not.

The parameter data is a floating point value in native form.

=item C<OSSL_PARAM_UTF8_STRING>

The parameter data is a printable string.

The pointer form

=item C<OSSL_PARAM_OCTET_STRING>

The parameter data is an arbitrary string of bytes.

=back

Additionally, this flag can be added to any type:

=over 4

=item C<OSSL_PARAM_POINTER_FLAG>

This can be used to indicate that constant data is or will be passed.
It works by assuming that the memory pointed at by the C<buffer> field
contains a pointer to the actual data.

If this C<OSSL_PARAM> is used to set a parameter, C<buffer_size> must
be set to the size of the data pointed at rather than the size of the
memory pointed at by the C<buffer> field.
If this C<OSSL_PARAM> is used in a parameter request, C<buffer_size>
is not relevant.
However, the responding function will set C<*return_size> to the size
of the actual data.

Note that the use of ths flag is B<fragile> and can only be safely
used for data that remains constant and in a constant location for a
long enough duration (such as the life-time of the object that
provides these parameters).

=back

For convenience, these types are provided:

=over 4

=item C<OSSL_PARAM_UTF8_STRING_PTR>

=item C<OSSL_PARAM_OCTET_STRING_PTR>

These are combinations of C<OSSL_PARAM_UTF8_STRING> as well as
C<OSSL_PARAM_OCTET_STRING> with C<OSSL_PARAM_POINTER_FLAG>.

=back

=back

=back

=head1 EXAMPLES

=head2 OSSL_PARAM

A couple of examples to just show how C<OSSL_PARAM> arrays could be
set up.

=head3 Example 1

This example is for setting parameters on something:

    #include <openssl/core.h>

    const char *foo = "some string";
    size_t foo_l = strlen(foo) + 1;
    const char bar[] = "some other string";
    const OSSL_PARAM set[] = {
        { "foo", OSSL_PARAM_UTF8_STRING_PTR, &foo, foo_l, NULL },
        { "bar", OSSL_PARAM_UTF8_STRING, &bar, sizeof(bar), NULL },
        { NULL, 0, NULL, 0, NULL }
    };

=head3 Example 2

This example is for requesting parameters on something:

    const char *foo = NULL;
    size_t foo_l;
    char bar[1024];
    size_t bar_l;
    const OSSL_PARAM request[] = {
        { "foo", OSSL_PARAM_UTF8_STRING_PTR, &foo, 0 /*irrelevant*/, &foo_l },
        { "bar", OSSL_PARAM_UTF8_STRING, &bar, sizeof(bar), &bar_l },
        { NULL, 0, NULL, 0, NULL }
    };

A responding function that receives this array (as C<params> in this
example) could fill in the parameters like this:

    /* const OSSL_PARAM *params */

    *(char **)params[0].buffer = "foo value";
    *params[0].return_size = 10; /* size of "foo value" incl NUL */

    memcpy(params[1].buffer, "bar value", 10);
    *params[1].return_size = 10; /* size of "bar value" incl NUL */

=head1 SEE ALSO

L<openssl-core-numbers.h(7)>

=head1 COPYRIGHT

Copyright 2019 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
