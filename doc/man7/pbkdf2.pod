=pod

=head1 NAME

pbkdf2 - PBKDF2 key derivation function

=head1 SYNOPSIS

 #include <openssl/kdf.h>

 int EVP_PKEY_CTX_set1_pbe_pass(EVP_PKEY_CTX *pctx, unsigned char *pass,
                                int passlen);

 int EVP_PKEY_CTX_set1_pbkdf2_salt(EVP_PKEY_CTX *pctx, unsigned char *salt,
                                   int saltlen);

 int EVP_PKEY_CTX_set_pbkdf2_md(EVP_PKEY_CTX *pctx, const EVP_MD *md);

 int EVP_PKEY_CTX_set_pbkdf2_iter(EVP_PKEY_CTX *pctx, int itercnt);

=head1 DESCRIPTION

The EVP_PKEY_PBKDF2 algorithm implements the PBKDF2 password based key
derivation function, as described in RFC 2898. It is an iterative HMAC-based
key derivation function that offers scaling by a linear work factor. PBKDF2 is
not memory-hard.

EVP_PKEY_CTX_set1_pbe_pass() sets the B<passlen> bytes long password.

EVP_PKEY_CTX_set1_pbkdf2_salt() sets the B<saltlen> bytes long salt value.

EVP_PKEY_CTX_set_pbkdf2_md() configures the cryptographic hash function that
is used for the internal HMAC computation.

EVP_PKEY_CTX_set_pbkdf2_iter() sets the iteration count, i.e. the linear work
factor.

=head1 STRING CTRLS

pbkdf2 also supports string based control operations via
L<EVP_PKEY_CTX_ctrl_str(3)>.
The B<password> can be directly specified using the B<type> parameter "pass" or
given in hex encoding using the "hexpass" parameter. Similarly, the B<salt> can
either be specified using the B<type> parameter "salt" or in hex encoding by
using the "hexsalt" parameter. To set the message digest function B<md>, the
"md" paramter is used. Finally, the work factor B<iter> can be set using the
"iter" parameter.

=head1 NOTES

All these functions are implemented as macros.

A context for PBKDF2 can be obtained by calling:

    EVP_PKEY_CTX *pctx = EVP_PKEY_new_id(EVP_PKEY_PBKDF2, NULL);

The output length of a PBKDF2 key derivation is specified via the length
parameter to the L<EVP_PKEY_derive(3)> function.

=head1 RETURN VALUES

All these functions return 1 for success and 0 or a negative value for failure.
In particular a return value of -2 indicates the operation is not supported by
the public key algorithm.

=head1 EXAMPLE

This example derives a 20-byte long test vector using PBKDF2-HMAC-SHA1 using
the password "password" and salt "salt". The iteration count (work factor) is
chosen to be 4096 iterations.

 EVP_PKEY_CTX *pctx;
 unsigned char out[20];
 size_t outlen = sizeof(out);

 pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_PBKDF2, NULL);

 if (EVP_PKEY_derive_init(pctx) <= 0) {
     error("EVP_PKEY_derive_init");
 }
 if (EVP_PKEY_CTX_set_pbkdf2_md(pctx, EVP_sha1()) <= 0) {
     error("EVP_PKEY_CTX_set_pbkdf2_md");
 }
 if (EVP_PKEY_CTX_set1_pbkdf2_salt(pctx, "salt", 4) <= 0) {
     error("EVP_PKEY_CTX_set1_pbkdf2_salt");
 }
 if (EVP_PKEY_CTX_set1_pbe_pass(pctx, "password", 8) <= 0) {
     error("EVP_PKEY_CTX_set1_pbe_pass");
 }
 if (EVP_PKEY_CTX_set_pbkdf2_iter(pctx, 4096) <= 0) {
     error("EVP_PKEY_CTX_set1_pbkdf2_pass");
 }
 if (EVP_PKEY_derive(pctx, out, &outlen) <= 0) {
     error("EVP_PKEY_derive");
 }

 {
     const unsigned char expected[sizeof(out)] = {
         0x4b, 0x00, 0x79, 0x01, 0xb7, 0x65, 0x48, 0x9a,
         0xbe, 0xad, 0x49, 0xd9, 0x26, 0xf7, 0x21, 0xd0,
         0x65, 0xa4, 0x29, 0xc1
     };

     assert(!memcmp(out, expected, sizeof(out)));
 }

 EVP_PKEY_CTX_free(pctx);

=head1 CONFORMING TO

RFC 2898

=head1 SEE ALSO

L<EVP_PKEY_CTX_new(3)>,
L<EVP_PKEY_CTX_ctrl_str(3)>,
L<EVP_PKEY_derive(3)>
L<scrypt(7)>

=head1 COPYRIGHT

Copyright 2017 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the OpenSSL license (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
