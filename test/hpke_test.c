/*
 * Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

#include <openssl/hpke.h>
#include <openssl/evp.h>
#include <openssl/core_names.h>
#include "testutil.h"

static int cmpkey(const EVP_PKEY *pkey,
                  const unsigned char *priv, size_t privlen,
                  const unsigned char *pub, size_t publen)
{
    const char *keytype;
    char curvename[80];
    unsigned char pubbuf[80];
    unsigned char privbuf[80];
    BIGNUM *privbn = NULL;
    size_t pubbuflen, privbuflen = 0;
    int ret = 0, ec;

    keytype = EVP_PKEY_get0_type_name(pkey);
    ec = (OPENSSL_strcasecmp(keytype, "EC") == 0);

    if (!TEST_true(publen <= sizeof(pubbuf) && privlen <= sizeof(privbuf)))
        return 0;
    if (!TEST_int_eq(EVP_PKEY_get_utf8_string_param(pkey,
                     OSSL_PKEY_PARAM_GROUP_NAME,
                     curvename, sizeof(curvename), NULL), ec))
            return 0;

    if (ec) {
        if (!TEST_int_eq(EVP_PKEY_get_bn_param(pkey, OSSL_PKEY_PARAM_PRIV_KEY,
                                               &privbn), priv != NULL))
            return 0;
        if (priv != NULL) {
            privbuflen = BN_bn2bin(privbn, privbuf);
            if (!TEST_int_eq(privbuflen, privlen))
                goto err;
        }
    } else {
        if (!TEST_int_eq(EVP_PKEY_get_octet_string_param(pkey,
                                                         OSSL_PKEY_PARAM_PRIV_KEY,
                                                         privbuf, sizeof(privbuf),
                                                         &privbuflen),
                         priv != NULL))
            goto err;
    }
    if (!TEST_true(EVP_PKEY_get_octet_string_param(pkey,
                       OSSL_PKEY_PARAM_ENCODED_PUBLIC_KEY,
                       pubbuf, sizeof(pubbuf), &pubbuflen)))
        goto err;
    if (priv != NULL && !TEST_mem_eq(privbuf, privbuflen, priv, privlen))
        goto err;
    if (pub != NULL && !TEST_mem_eq(pubbuf, pubbuflen, pub, publen))
        goto err;
    ret = 1;
err:
    BN_free(privbn);
    return ret;
}

typedef struct {
    const char *keytype;
    const char *eccurve;
    const char *kemdigest;
    const char *hpkedigest;
    const char *aeadname;
    const unsigned char *ikmE;
    size_t ikmElen;
    const unsigned char *ikmR;
    size_t ikmRlen;
    const unsigned char *expected_pkRm;
    size_t expected_pkRmlen;
    const unsigned char *expected_skRm;
    size_t expected_skRmlen;
    const unsigned char *expected_enc;
    size_t expected_enclen;
    const unsigned char *expected_secret;
    size_t expected_secretlen;
    const unsigned char *ksinfo;
    size_t ksinfolen;
    const unsigned char *ikmAuth;
    size_t ikmAuthlen;
    const unsigned char *psk;
    size_t psklen;
    const unsigned char *pskid;
    size_t pskidlen;
} TEST_BASEDATA;

typedef struct
{
    int seq;
    const unsigned char *pt;
    size_t ptlen;
    const unsigned char *aad;
    size_t aadlen;
    const unsigned char *expected_ct;
    size_t expected_ctlen;
} TEST_AEADDATA;

typedef struct
{
    const unsigned char *context;
    size_t contextlen;
    const unsigned char *expected_secret;
    size_t expected_secretlen;
} TEST_EXPORTDATA;

static int do_testhpke(const TEST_BASEDATA *base,
                       const TEST_AEADDATA *aead, size_t aeadsz,
                       const TEST_EXPORTDATA *export, size_t exportsz)
{
    OSSL_LIB_CTX *libctx = NULL;
    const char *propq = NULL;
    OSSL_HPKE_KEM *encapkem = NULL, *decapkem = NULL;
    OSSL_HPKE_CTX *sealctx = NULL, *openctx = NULL;
    EVP_PKEY_CTX *ectx = NULL, *dctx = NULL;

    unsigned char secret[64];
    unsigned char ct[256];
    unsigned char enc[256];
    unsigned char ptout[64];
    size_t secretlen = sizeof(secret);
    size_t ptoutlen = sizeof(ptout);
    size_t enclen = sizeof(enc);
    size_t ctlen = sizeof(ct);
    EVP_PKEY *pub = NULL, *priv = NULL, *authpub = NULL, *authpriv = NULL;
    int ret = 0, i;

    if (!TEST_ptr(encapkem = OSSL_HPKE_KEM_new(base->keytype, base->eccurve,
                                               "HKDF", base->kemdigest)))
        goto end;

    if (!TEST_true(OSSL_HPKE_KEM_derivekey_init(encapkem, libctx, propq)))
        goto end;
    if (!TEST_true(OSSL_HPKE_KEM_derivekey(encapkem, &priv, &pub,
                                           base->ikmR, base->ikmRlen)))
        goto end;
    if (!TEST_true(cmpkey(pub, NULL, 0,
                          base->expected_pkRm, base->expected_pkRmlen)))
        goto end;
    if (!TEST_true(cmpkey(priv,
                   base->expected_skRm, base->expected_skRmlen, NULL, 0)))
        goto end;
    if (base->ikmAuth != NULL) {
        if (!TEST_true(OSSL_HPKE_KEM_derivekey(encapkem, &authpriv, &authpub,
                                               base->ikmAuth, base->ikmAuthlen)))
            goto end;
    }

    if (!TEST_ptr(ectx = EVP_PKEY_CTX_new_from_pkey(libctx, pub, propq)))
        goto end;
    if (!TEST_true(OSSL_HPKE_KEM_encapsulate_init(ectx, encapkem, authpriv,
                                                  base->ikmE, base->ikmElen)))
        goto end;
    if (!TEST_true(OSSL_HPKE_KEM_encapsulate(ectx, enc, &enclen,
                                             secret, &secretlen)))
        goto end;
    if (!TEST_true(TEST_mem_eq(base->expected_enc, base->expected_enclen,
                               enc, enclen)))
        goto end;
    if (!TEST_true(TEST_mem_eq(base->expected_secret, base->expected_secretlen,
                               secret, secretlen)))
        goto end;

    if (!TEST_ptr(sealctx = OSSL_HPKE_CTX_new(encapkem, 1, base->hpkedigest,
                                              base->aeadname, libctx, propq)))
        goto end;

    if (!TEST_true(OSSL_HPKE_CTX_keyschedule_psk(sealctx,
                                             base->ksinfo, base->ksinfolen,
                                             secret, secretlen,
                                             base->psk, base->psklen,
                                             base->pskid, base->pskidlen)))
        goto end;
    if (!TEST_true(OSSL_HPKE_CTX_seal_init(sealctx)))
        goto end;
    for (i = 0; i < (int)aeadsz; ++i) {
        ctlen = sizeof(ct);
        OPENSSL_cleanse(ct, ctlen);
        //OSSL_HPKE_CTX_set_seq(sealctx, id);
        if (!TEST_true(OSSL_HPKE_CTX_seal(sealctx, ct, &ctlen,
                                          aead[i].aad, aead[i].aadlen,
                                          aead[i].pt, aead[i].ptlen)))
            goto end;
        if (!TEST_true(TEST_mem_eq(ct, ctlen,
                                   aead[i].expected_ct, aead[i].expected_ctlen)))
            goto end;
    }

    if (!TEST_ptr(decapkem = OSSL_HPKE_KEM_new(base->keytype, base->eccurve,
                                               "HKDF", base->kemdigest)))
        goto end;

    if (!TEST_ptr(dctx = EVP_PKEY_CTX_new_from_pkey(libctx, priv, propq)))
        goto end;
    if (!TEST_true(OSSL_HPKE_KEM_decapsulate_init(dctx, decapkem, NULL)))
        goto end;

    OPENSSL_cleanse(secret, sizeof(secret));
    secretlen = sizeof(secret);
    if (!TEST_true(OSSL_HPKE_KEM_decapsulate(dctx, secret, &secretlen,
                                             enc, enclen)))
        goto end;
    if (!TEST_true(TEST_mem_eq(base->expected_secret, base->expected_secretlen,
                               secret, secretlen)))
        goto end;

    if (!TEST_ptr(openctx = OSSL_HPKE_CTX_new(decapkem, 0, base->hpkedigest,
                                              base->aeadname,
                                              libctx, propq)))
        goto end;

    if (!TEST_true(OSSL_HPKE_CTX_keyschedule_psk(openctx,
                                                 base->ksinfo, base->ksinfolen,
                                                 secret, secretlen,
                                                 base->psk, base->psklen,
                                                 base->pskid, base->pskidlen)))
        goto end;
    if (!TEST_true(OSSL_HPKE_CTX_open_init(openctx)))
        goto end;
    for (i = 0; i < (int)aeadsz; ++i) {
        ptoutlen = sizeof(ptout);
        OPENSSL_cleanse(ptout, ptoutlen);
        if (!TEST_true(OSSL_HPKE_CTX_open(openctx, ptout, &ptoutlen,
                                          aead[i].aad, aead[i].aadlen,
                                          aead[i].expected_ct,
                                          aead[i].expected_ctlen)))
            goto end;
        if (!TEST_mem_eq(aead[i].pt, aead[i].ptlen, ptout, ptoutlen))
            goto end;
    }
    for (i = 0; i < (int)exportsz; ++i) {
        size_t len = export[i].expected_secretlen;

        if (!TEST_true(OSSL_HPKE_CTX_export(openctx, secret, len,
                                            export[i].context,
                                            export[i].contextlen)))
            goto end;
        if (!TEST_mem_eq(secret, len,
                         export[i].expected_secret,
                         export[i].expected_secretlen))
            goto end;
    }
    ret = 1;
end:
    OSSL_HPKE_KEM_free(decapkem);
    OSSL_HPKE_KEM_free(encapkem);
    OSSL_HPKE_CTX_free(sealctx);
    OSSL_HPKE_CTX_free(openctx);
    EVP_PKEY_free(authpub);
    EVP_PKEY_free(authpriv);
    EVP_PKEY_free(pub);
    EVP_PKEY_free(priv);
    EVP_PKEY_CTX_free(ectx);
    EVP_PKEY_CTX_free(dctx);
    return ret;
}

const unsigned char pt[] = {
    0x42, 0x65, 0x61, 0x75, 0x74, 0x79, 0x20, 0x69,
    0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x2c,
    0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x20, 0x62,
    0x65, 0x61, 0x75, 0x74, 0x79
};
const unsigned char ksinfo[] = {
    0x4f, 0x64, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x61,
    0x20, 0x47, 0x72, 0x65, 0x63, 0x69, 0x61, 0x6e,
    0x20, 0x55, 0x72, 0x6e
};

static int x25519kdfsha256_hkdfsha256_aes128gcm_psk_test(void)
{
    const unsigned char ikme[] = {
        0x78, 0x62, 0x8c, 0x35, 0x4e, 0x46, 0xf3, 0xe1,
        0x69, 0xbd, 0x23, 0x1b, 0xe7, 0xb2, 0xff, 0x1c,
        0x77, 0xaa, 0x30, 0x24, 0x60, 0xa2, 0x6d, 0xbf,
        0xa1, 0x55, 0x15, 0x68, 0x4c, 0x00, 0x13, 0x0b
    };
    const unsigned char ikmr[] = {
        0xd4, 0xa0, 0x9d, 0x09, 0xf5, 0x75, 0xfe, 0xf4,
        0x25, 0x90, 0x5d, 0x2a, 0xb3, 0x96, 0xc1, 0x44,
        0x91, 0x41, 0x46, 0x3f, 0x69, 0x8f, 0x8e, 0xfd,
        0xb7, 0xac, 0xcf, 0xaf, 0xf8, 0x99, 0x50, 0x98
    };
    const unsigned char ikmrpub[] = {
        0x9f, 0xed, 0x7e, 0x8c, 0x17, 0x38, 0x75, 0x60,
        0xe9, 0x2c, 0xc6, 0x46, 0x2a, 0x68, 0x04, 0x96,
        0x57, 0x24, 0x6a, 0x09, 0xbf, 0xa8, 0xad, 0xe7,
        0xae, 0xfe, 0x58, 0x96, 0x72, 0x01, 0x63, 0x66
    };
    const unsigned char ikmrpriv[] = {
        0xc5, 0xeb, 0x01, 0xeb, 0x45, 0x7f, 0xe6, 0xc6,
        0xf5, 0x75, 0x77, 0xc5, 0x41, 0x3b, 0x93, 0x15,
        0x50, 0xa1, 0x62, 0xc7, 0x1a, 0x03, 0xac, 0x8d,
        0x19, 0x6b, 0xab, 0xbd, 0x4e, 0x5c, 0xe0, 0xfd
    };
    const unsigned char psk[] = {
        0x02, 0x47, 0xfd, 0x33, 0xb9, 0x13, 0x76, 0x0f,
        0xa1, 0xfa, 0x51, 0xe1, 0x89, 0x2d, 0x9f, 0x30,
        0x7f, 0xbe, 0x65, 0xeb, 0x17, 0x1e, 0x81, 0x32,
        0xc2, 0xaf, 0x18, 0x55, 0x5a, 0x73, 0x8b, 0x82
    };
    const unsigned char pskid[] = {
        0x45, 0x6e, 0x6e, 0x79, 0x6e, 0x20, 0x44, 0x75,
        0x72, 0x69, 0x6e, 0x20, 0x61, 0x72, 0x61, 0x6e,
        0x20, 0x4d, 0x6f, 0x72, 0x69, 0x61
    };
    const unsigned char expected_enc[] = {
        0x0a, 0xd0, 0x95, 0x0d, 0x9f, 0xb9, 0x58, 0x8e,
        0x59, 0x69, 0x0b, 0x74, 0xf1, 0x23, 0x7e, 0xcd,
        0xf1, 0xd7, 0x75, 0xcd, 0x60, 0xbe, 0x2e, 0xca,
        0x57, 0xaf, 0x5a, 0x4b, 0x04, 0x71, 0xc9, 0x1b
    };
    const unsigned char expected_shared_secret[] = {
        0x72, 0x76, 0x99, 0xf0, 0x09, 0xff, 0xe3, 0xc0,
        0x76, 0x31, 0x50, 0x19, 0xc6, 0x96, 0x48, 0x36,
        0x6b, 0x69, 0x17, 0x14, 0x39, 0xbd, 0x7d, 0xd0,
        0x80, 0x77, 0x43, 0xbd, 0xe7, 0x69, 0x86, 0xcd
    };

    const unsigned char aad0[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x30 };
    const unsigned char ct0[] = {
        0xe5, 0x2c, 0x6f, 0xed, 0x7f, 0x75, 0x8d, 0x0c,
        0xf7, 0x14, 0x56, 0x89, 0xf2, 0x1b, 0xc1, 0xbe,
        0x6e, 0xc9, 0xea, 0x09, 0x7f, 0xef, 0x4e, 0x95,
        0x94, 0x40, 0x01, 0x2f, 0x4f, 0xeb, 0x73, 0xfb,
        0x61, 0x1b, 0x94, 0x61, 0x99, 0xe6, 0x81, 0xf4,
        0xcf, 0xc3, 0x4d, 0xb8, 0xea
    };
    const unsigned char aad1[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x31 };
    const unsigned char ct1[] = {
        0x49, 0xf3, 0xb1, 0x9b, 0x28, 0xa9, 0xea, 0x9f,
        0x43, 0xe8, 0xc7, 0x12, 0x04, 0xc0, 0x0d, 0x4a,
        0x49, 0x0e, 0xe7, 0xf6, 0x13, 0x87, 0xb6, 0x71,
        0x9d, 0xb7, 0x65, 0xe9, 0x48, 0x12, 0x3b, 0x45,
        0xb6, 0x16, 0x33, 0xef, 0x05, 0x9b, 0xa2, 0x2c,
        0xd6, 0x24, 0x37, 0xc8, 0xba
    };
    const unsigned char aad2[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x32 };
    const unsigned char ct2[] = {
        0x25, 0x7c, 0xa6, 0xa0, 0x84, 0x73, 0xdc, 0x85,
        0x1f, 0xde, 0x45, 0xaf, 0xd5, 0x98, 0xcc, 0x83,
        0xe3, 0x26, 0xdd, 0xd0, 0xab, 0xe1, 0xef, 0x23,
        0xba, 0xa3, 0xba, 0xa4, 0xdd, 0x8c, 0xde, 0x99,
        0xfc, 0xe2, 0xc1, 0xe8, 0xce, 0x68, 0x7b, 0x0b,
        0x47, 0xea, 0xd1, 0xad, 0xc9
    };
    const unsigned char export1[] = {
        0xdf, 0xf1, 0x7a, 0xf3, 0x54, 0xc8, 0xb4, 0x16,
        0x73, 0x56, 0x7d, 0xb6, 0x25, 0x9f, 0xd6, 0x02,
        0x99, 0x67, 0xb4, 0xe1, 0xaa, 0xd1, 0x30, 0x23,
        0xc2, 0xae, 0x5d, 0xf8, 0xf4, 0xf4, 0x3b, 0xf6
    };
    const unsigned char context2[] = { 0x00 };
    const unsigned char export2[] = {
        0x6a, 0x84, 0x72, 0x61, 0xd8, 0x20, 0x7f, 0xe5,
        0x96, 0xbe, 0xfb, 0x52, 0x92, 0x84, 0x63, 0x88,
        0x1a, 0xb4, 0x93, 0xda, 0x34, 0x5b, 0x10, 0xe1,
        0xdc, 0xc6, 0x45, 0xe3, 0xb9, 0x4e, 0x2d, 0x95
    };
    const unsigned char context3[] = {
        0x54, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74,
        0x65, 0x78, 0x74
    };
    const unsigned char export3[] = {
        0x8a, 0xff, 0x52, 0xb4, 0x5a, 0x1b, 0xe3, 0xa7,
        0x34, 0xbc, 0x7a, 0x41, 0xe2, 0x0b, 0x4e, 0x05,
        0x5a, 0xd4, 0xc4, 0xd2, 0x21, 0x04, 0xb0, 0xc2,
        0x02, 0x85, 0xa7, 0xc4, 0x30, 0x24, 0x01, 0xcd
    };
    const TEST_BASEDATA pskdata = {
        "X25519", NULL, "SHA256", "SHA256", "AES-128-GCM",
        ikme, sizeof(ikme),
        ikmr, sizeof(ikmr),
        ikmrpub, sizeof(ikmrpub),
        ikmrpriv, sizeof(ikmrpriv),
        expected_enc,sizeof(expected_enc),
        expected_shared_secret, sizeof(expected_shared_secret),
        ksinfo, sizeof(ksinfo),
        NULL, 0,    /* No Auth */
        psk, sizeof(psk),
        pskid, sizeof(pskid),
    };
    const TEST_AEADDATA aeaddata[] = {
        {
            0,
            pt, sizeof(pt),
            aad0, sizeof(aad0),
            ct0, sizeof(ct0)
        },
        {
            1,
            pt, sizeof(pt),
            aad1, sizeof(aad1),
            ct1, sizeof(ct1)
        },
        {
            2,
            pt, sizeof(pt),
            aad2, sizeof(aad2),
            ct2, sizeof(ct2)
        }
    };
    const TEST_EXPORTDATA exportdata[] = {
        { NULL, 0, export1, sizeof(export1) },
        { context2, sizeof(context2), export2, sizeof(export2) },
        { context3, sizeof(context3), export3, sizeof(export3) },
    };
    return do_testhpke(&pskdata, aeaddata, OSSL_NELEM(aeaddata),
                       exportdata, OSSL_NELEM(exportdata));
}

static int x25519kdfsha256_hkdfsha256_aes128gcm_base_test(void)
{
    const unsigned char ikme[] = {
        0x72, 0x68, 0x60, 0x0d, 0x40, 0x3f, 0xce, 0x43,
        0x15, 0x61, 0xae, 0xf5, 0x83, 0xee, 0x16, 0x13,
        0x52, 0x7c, 0xff, 0x65, 0x5c, 0x13, 0x43, 0xf2,
        0x98, 0x12, 0xe6, 0x67, 0x06, 0xdf, 0x32, 0x34
    };
    const unsigned char ikmr[] = {
        0x6d, 0xb9, 0xdf, 0x30, 0xaa, 0x07, 0xdd, 0x42,
        0xee, 0x5e, 0x81, 0x81, 0xaf, 0xdb, 0x97, 0x7e,
        0x53, 0x8f, 0x5e, 0x1f, 0xec, 0x8a, 0x06, 0x22,
        0x3f, 0x33, 0xf7, 0x01, 0x3e, 0x52, 0x50, 0x37
    };
    const unsigned char ikmrpub[] = {
        0x39, 0x48, 0xcf, 0xe0, 0xad, 0x1d, 0xdb, 0x69,
        0x5d, 0x78, 0x0e, 0x59, 0x07, 0x71, 0x95, 0xda,
        0x6c, 0x56, 0x50, 0x6b, 0x02, 0x73, 0x29, 0x79,
        0x4a, 0xb0, 0x2b, 0xca, 0x80, 0x81, 0x5c, 0x4d
    };
    const unsigned char ikmrpriv[] = {
        0x46, 0x12, 0xc5, 0x50, 0x26, 0x3f, 0xc8, 0xad,
        0x58, 0x37, 0x5d, 0xf3, 0xf5, 0x57, 0xaa, 0xc5,
        0x31, 0xd2, 0x68, 0x50, 0x90, 0x3e, 0x55, 0xa9,
        0xf2, 0x3f, 0x21, 0xd8, 0x53, 0x4e, 0x8a, 0xc8
    };
    const unsigned char expected_enc[] = {
        0x37, 0xfd, 0xa3, 0x56, 0x7b, 0xdb, 0xd6, 0x28,
        0xe8, 0x86, 0x68, 0xc3, 0xc8, 0xd7, 0xe9, 0x7d,
        0x1d, 0x12, 0x53, 0xb6, 0xd4, 0xea, 0x6d, 0x44,
        0xc1, 0x50, 0xf7, 0x41, 0xf1, 0xbf, 0x44, 0x31
    };
    const unsigned char expected_shared_secret[] = {
        0xfe, 0x0e, 0x18, 0xc9, 0xf0, 0x24, 0xce, 0x43,
        0x79, 0x9a, 0xe3, 0x93, 0xc7, 0xe8, 0xfe, 0x8f,
        0xce, 0x9d, 0x21, 0x88, 0x75, 0xe8, 0x22, 0x7b,
        0x01, 0x87, 0xc0, 0x4e, 0x7d, 0x2e, 0xa1, 0xfc
    };
    const unsigned char aead0[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x30 };
    const unsigned char ct0[] = {
        0xf9, 0x38, 0x55, 0x8b, 0x5d, 0x72, 0xf1, 0xa2,
        0x38, 0x10, 0xb4, 0xbe, 0x2a, 0xb4, 0xf8, 0x43,
        0x31, 0xac, 0xc0, 0x2f, 0xc9, 0x7b, 0xab, 0xc5,
        0x3a, 0x52, 0xae, 0x82, 0x18, 0xa3, 0x55, 0xa9,
        0x6d, 0x87, 0x70, 0xac, 0x83, 0xd0, 0x7b, 0xea,
        0x87, 0xe1, 0x3c, 0x51, 0x2a
    };
    const unsigned char aead1[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x31 };
    const unsigned char ct1[] = {
        0xaf, 0x2d, 0x7e, 0x9a, 0xc9, 0xae, 0x7e, 0x27,
        0x0f, 0x46, 0xba, 0x1f, 0x97, 0x5b, 0xe5, 0x3c,
        0x09, 0xf8, 0xd8, 0x75, 0xbd, 0xc8, 0x53, 0x54,
        0x58, 0xc2, 0x49, 0x4e, 0x8a, 0x6e, 0xab, 0x25,
        0x1c, 0x03, 0xd0, 0xc2, 0x2a, 0x56, 0xb8, 0xca,
        0x42, 0xc2, 0x06, 0x3b, 0x84
    };
    const unsigned char export1[] = {
        0x38, 0x53, 0xfe, 0x2b, 0x40, 0x35, 0x19, 0x5a,
        0x57, 0x3f, 0xfc, 0x53, 0x85, 0x6e, 0x77, 0x05,
        0x8e, 0x15, 0xd9, 0xea, 0x06, 0x4d, 0xe3, 0xe5,
        0x9f, 0x49, 0x61, 0xd0, 0x09, 0x52, 0x50, 0xee
    };
    const unsigned char context2[] = { 0x00 };
    const unsigned char export2[] = {
        0x2e, 0x8f, 0x0b, 0x54, 0x67, 0x3c, 0x70, 0x29,
        0x64, 0x9d, 0x4e, 0xb9, 0xd5, 0xe3, 0x3b, 0xf1,
        0x87, 0x2c, 0xf7, 0x6d, 0x62, 0x3f, 0xf1, 0x64,
        0xac, 0x18, 0x5d, 0xa9, 0xe8, 0x8c, 0x21, 0xa5
    };
    const unsigned char context3[] = {
        0x54, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74,
        0x65, 0x78, 0x74
    };
    const unsigned char export3[] = {
        0xe9, 0xe4, 0x30, 0x65, 0x10, 0x2c, 0x38, 0x36,
        0x40, 0x1b, 0xed, 0x8c, 0x3c, 0x3c, 0x75, 0xae,
        0x46, 0xbe, 0x16, 0x39, 0x86, 0x93, 0x91, 0xd6,
        0x2c, 0x61, 0xf1, 0xec, 0x7a, 0xf5, 0x49, 0x31
    };
    const TEST_BASEDATA basedata = {
        "X25519", NULL, "SHA256", "SHA256", "AES-128-GCM",
        ikme, sizeof(ikme),
        ikmr, sizeof(ikmr),
        ikmrpub, sizeof(ikmrpub),
        ikmrpriv, sizeof(ikmrpriv),
        expected_enc,sizeof(expected_enc),
        expected_shared_secret, sizeof(expected_shared_secret),
        ksinfo, sizeof(ksinfo)
    };
    const TEST_AEADDATA aeaddata[] = {
        {
            0,
            pt, sizeof(pt),
            aead0, sizeof(aead0),
            ct0, sizeof(ct0)
        },
        {
            1,
            pt, sizeof(pt),
            aead1, sizeof(aead1),
            ct1, sizeof(ct1)
        }
    };
    const TEST_EXPORTDATA exportdata[] = {
        { NULL, 0, export1, sizeof(export1) },
        { context2, sizeof(context2), export2, sizeof(export2) },
        { context3, sizeof(context3), export3, sizeof(export3) },
    };
   return do_testhpke(&basedata, aeaddata, OSSL_NELEM(aeaddata),
                      exportdata, OSSL_NELEM(exportdata));
}

static int P256kdfsha256_hkdfsha256_aes128gcm_base_test(void)
{
    const unsigned char ikme[] = {
        0x42, 0x70, 0xe5, 0x4f, 0xfd, 0x08, 0xd7, 0x9d,
        0x59, 0x28, 0x02, 0x0a, 0xf4, 0x68, 0x6d, 0x8f,
        0x6b, 0x7d, 0x35, 0xdb, 0xe4, 0x70, 0x26, 0x5f,
        0x1f, 0x5a, 0xa2, 0x28, 0x16, 0xce, 0x86, 0x0e
    };
    const unsigned char ikmr[] = {
        0x66, 0x8b, 0x37, 0x17, 0x1f, 0x10, 0x72, 0xf3,
        0xcf, 0x12, 0xea, 0x8a, 0x23, 0x6a, 0x45, 0xdf,
        0x23, 0xfc, 0x13, 0xb8, 0x2a, 0xf3, 0x60, 0x9a,
        0xd1, 0xe3, 0x54, 0xf6, 0xef, 0x81, 0x75, 0x50
    };
    const unsigned char ikmrpub[] = {
        0x04, 0xfe, 0x8c, 0x19, 0xce, 0x09, 0x05, 0x19,
        0x1e, 0xbc, 0x29, 0x8a, 0x92, 0x45, 0x79, 0x25,
        0x31, 0xf2, 0x6f, 0x0c, 0xec, 0xe2, 0x46, 0x06,
        0x39, 0xe8, 0xbc, 0x39, 0xcb, 0x7f, 0x70, 0x6a,
        0x82, 0x6a, 0x77, 0x9b, 0x4c, 0xf9, 0x69, 0xb8,
        0xa0, 0xe5, 0x39, 0xc7, 0xf6, 0x2f, 0xb3, 0xd3,
        0x0a, 0xd6, 0xaa, 0x8f, 0x80, 0xe3, 0x0f, 0x1d,
        0x12, 0x8a, 0xaf, 0xd6, 0x8a, 0x2c, 0xe7, 0x2e,
        0xa0
    };
    const unsigned char ikmrpriv[] = {
        0xf3, 0xce, 0x7f, 0xda, 0xe5, 0x7e, 0x1a, 0x31,
        0x0d, 0x87, 0xf1, 0xeb, 0xbd, 0xe6, 0xf3, 0x28,
        0xbe, 0x0a, 0x99, 0xcd, 0xbc, 0xad, 0xf4, 0xd6,
        0x58, 0x9c, 0xf2, 0x9d, 0xe4, 0xb8, 0xff, 0xd2
    };
    const unsigned char expected_enc[] = {
        0x04, 0xa9, 0x27, 0x19, 0xc6, 0x19, 0x5d, 0x50,
        0x85, 0x10, 0x4f, 0x46, 0x9a, 0x8b, 0x98, 0x14,
        0xd5, 0x83, 0x8f, 0xf7, 0x2b, 0x60, 0x50, 0x1e,
        0x2c, 0x44, 0x66, 0xe5, 0xe6, 0x7b, 0x32, 0x5a,
        0xc9, 0x85, 0x36, 0xd7, 0xb6, 0x1a, 0x1a, 0xf4,
        0xb7, 0x8e, 0x5b, 0x7f, 0x95, 0x1c, 0x09, 0x00,
        0xbe, 0x86, 0x3c, 0x40, 0x3c, 0xe6, 0x5c, 0x9b,
        0xfc, 0xb9, 0x38, 0x26, 0x57, 0x22, 0x2d, 0x18,
        0xc4
    };
    const unsigned char expected_shared_secret[] = {
        0xc0, 0xd2, 0x6a, 0xea, 0xb5, 0x36, 0x60, 0x9a,
        0x57, 0x2b, 0x07, 0x69, 0x5d, 0x93, 0x3b, 0x58,
        0x9d, 0xcf, 0x36, 0x3f, 0xf9, 0xd9, 0x3c, 0x93,
        0xad, 0xea, 0x53, 0x7a, 0xea, 0xbb, 0x8c, 0xb8
    };
    const unsigned char aead0[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x30 };
    const unsigned char ct0[] = {
        0x5a, 0xd5, 0x90, 0xbb, 0x8b, 0xaa, 0x57, 0x7f,
        0x86, 0x19, 0xdb, 0x35, 0xa3, 0x63, 0x11, 0x22,
        0x6a, 0x89, 0x6e, 0x73, 0x42, 0xa6, 0xd8, 0x36,
        0xd8, 0xb7, 0xbc, 0xd2, 0xf2, 0x0b, 0x6c, 0x7f,
        0x90, 0x76, 0xac, 0x23, 0x2e, 0x3a, 0xb2, 0x52,
        0x3f, 0x39, 0x51, 0x34, 0x34
    };
    const unsigned char aead1[] = { 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x2d, 0x31 };
    const unsigned char ct1[] = {
        0xfa, 0x6f, 0x03, 0x7b, 0x47, 0xfc, 0x21, 0x82,
        0x6b, 0x61, 0x01, 0x72, 0xca, 0x96, 0x37, 0xe8,
        0x2d, 0x6e, 0x58, 0x01, 0xeb, 0x31, 0xcb, 0xd3,
        0x74, 0x82, 0x71, 0xaf, 0xfd, 0x4e, 0xcb, 0x06,
        0x64, 0x6e, 0x03, 0x29, 0xcb, 0xdf, 0x3c, 0x3c,
        0xd6, 0x55, 0xb2, 0x8e, 0x82
    };
    const unsigned char export1[] = {
        0x5e, 0x9b, 0xc3, 0xd2, 0x36, 0xe1, 0x91, 0x1d,
        0x95, 0xe6, 0x5b, 0x57, 0x6a, 0x8a, 0x86, 0xd4,
        0x78, 0xfb, 0x82, 0x7e, 0x8b, 0xdf, 0xe7, 0x7b,
        0x74, 0x1b, 0x28, 0x98, 0x90, 0x49, 0x0d, 0x4d
    };
    const unsigned char context2[] = { 0x00 };
    const unsigned char export2[] = {
        0x6c, 0xff, 0x87, 0x65, 0x89, 0x31, 0xbd, 0xa8,
        0x3d, 0xc8, 0x57, 0xe6, 0x35, 0x3e, 0xfe, 0x49,
        0x87, 0xa2, 0x01, 0xb8, 0x49, 0x65, 0x8d, 0x9b,
        0x04, 0x7a, 0xab, 0x4c, 0xf2, 0x16, 0xe7, 0x96
    };
    const unsigned char context3[] = {
        0x54, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74,
        0x65, 0x78, 0x74
    };
    const unsigned char export3[] = {
        0xd8, 0xf1, 0xea, 0x79, 0x42, 0xad, 0xbb, 0xa7,
        0x41, 0x2c, 0x6d, 0x43, 0x1c, 0x62, 0xd0, 0x13,
        0x71, 0xea, 0x47, 0x6b, 0x82, 0x3e, 0xb6, 0x97,
        0xe1, 0xf6, 0xe6, 0xca, 0xe1, 0xda, 0xb8, 0x5a
    };
    const TEST_BASEDATA basedata = {
        "EC", "P-256", "SHA256", "SHA256", "AES-128-GCM",
        ikme, sizeof(ikme),
        ikmr, sizeof(ikmr),
        ikmrpub, sizeof(ikmrpub),
        ikmrpriv, sizeof(ikmrpriv),
        expected_enc,sizeof(expected_enc),
        expected_shared_secret, sizeof(expected_shared_secret),
        ksinfo, sizeof(ksinfo)
    };
    const TEST_AEADDATA aeaddata[] = {
        {
            0,
            pt, sizeof(pt),
            aead0, sizeof(aead0),
            ct0, sizeof(ct0)
        },
        {
            1,
            pt, sizeof(pt),
            aead1, sizeof(aead1),
            ct1, sizeof(ct1)
        }
    };
    const TEST_EXPORTDATA exportdata[] = {
        { NULL, 0, export1, sizeof(export1) },
        { context2, sizeof(context2), export2, sizeof(export2) },
        { context3, sizeof(context3), export3, sizeof(export3) },
    };
   return do_testhpke(&basedata, aeaddata, OSSL_NELEM(aeaddata),
                      exportdata, OSSL_NELEM(exportdata));
}

int setup_tests(void)
{
    ADD_TEST(x25519kdfsha256_hkdfsha256_aes128gcm_base_test);
    ADD_TEST(x25519kdfsha256_hkdfsha256_aes128gcm_psk_test);
    ADD_TEST(P256kdfsha256_hkdfsha256_aes128gcm_base_test);
    return 1;
}

void cleanup_tests(void)
{
}
