#!/bin/bash -ue

## interpret options, possibly print usage
options=$(getopt -o "hvn" -l "old,help" -a -- "$@")

eval set -- "$options"

ENABLE_LEGACY=0
REMOVE_LINKS=0
while true
do
	case "$1" in
	"-h" | "--help")
		echo "Usage: c_rehash [-old] [-h] [-help] [-v] [dirs...]"
		echo "   -old use old-style digest"
		echo "   -h or -help print this help text"
		echo "   -v print files removed and linked"

		exit 0
	;;

	"-v")
		function cp { /usr/bin/cp -v "$@";}
		function ln { /usr/bin/ln -v "$@";}
		function rm { /usr/bin/rm -v "$@";}
	;;

	"--old")
		ENABLE_LEGACY=1
	;;

	# undocumented
	"-n")
		REMOVE_LINKS=1
	;;

	"--")
		shift
		break
	;;
	esac
	shift
done

## our internal variables, not influenced by options
declare -A CREATED
CAN_SYMLINK=$(command -v ln >/dev/null && echo 1 || echo 0)
DEFAULT_DIR={- quotify1($config{openssldir}) -}
[[ $OSTYPE == "cygwin" || $OSTYPE == "msys" || $OSTYPE == "win32" ]] && PATH_DELIM=';' || PATH_DELIM=':'


## verify openssl is available
PATH="{- $config{prefix} -}$PATH_DELIM$PATH"
openssl version >/dev/null || {
	echo "c_rehash: rehashing skipped ('openssl' program not available)" >&2

	exit 1
}


## define functions
# given a target directory, loop through all files (non-recursive) and attempt to link supported types
function hashDir {
	dir=$1

	echo "c_rehash: scanning $dir"
	cd "$dir"

	if [[ ${REMOVE_LINKS} -eq 1 ]]; then
		for f in [0-9a-f]*.[01]; do
			[[ -L "$f" ]] && rm "$f"
		done
	fi

	for f in *.pem *.crt *.cer *.crl; do
		[[ -e "$f" ]] || continue

		hdr=$(grep -- '-----BEGIN' "$f")
		hdr=${hdr//-/}

		certRegexp='^BEGIN (X509 |TRUSTED |)CERTIFICATE$'
		if [[ $hdr =~ $certRegexp ]]; then
			linkHash 0 "$f"
		elif [[ $hdr == "BEGIN X509 CRL" ]]; then
			linkHash 1 "$f"
		else
			echo "WARNING: $f does not contain a certificate or CRL: skipping" >&2
			continue
		fi
	done
}

# given a type and filepath, create a link/copy of file based on its hash
function linkHash {
	isCrl="$1"
	f="$2"

	[[ $isCrl -eq 1 ]] && cmd='crl' || cmd='x509'
	[[ $isCrl -eq 1 ]] && opt='-hash' || opt='-subject_hash'
	[[ $ENABLE_LEGACY -eq 1 ]] && opt=${opt}_old

	  hash=$(openssl $cmd $opt -noout -in "$f")
	fprint=$(openssl $cmd -fingerprint  -noout -in "$f")
	fprint=${fprint##*=}
	fprint=${fprint//:/}

	suffix=0
	[[ $isCrl -eq 1 ]] && extra="r" || extra=""

	while [[ -n ${CREATED[$hash.$extra$suffix]} ]]; do
		[[ ${CREATED[$hash.$extra$suffix]} -eq $fprint ]] && {
			echo "WARNING: Skipping duplicate certificate $f" >&2
			return
		}

		((suffix++))
	done

	if [[ $CAN_SYMLINK -eq 1 ]]; then
		ln -s "$f" "$hash.$extra$suffix"
	else
		cp "$f" "$hash.$extra$suffix"
	fi

	CREATED[$hash.$extra$suffix]=$fprint
}


## determine target directories and loop through them

if [[ $# -gt 0 ]]; then
	dirList=("$@")
elif [[ -n $SSL_CERT_DIR ]]; then
	IFS=$PATH_DELIM read -r -a dirList <<< "$SSL_CERT_DIR"
else
	dirList=("$DEFAULT_DIR/certs")
fi

for d in "${dirList[@]}"
do
	[[ ! -w $d ]] && {
		echo "Skipping $d, can't write" >&2
		((errs++))
		continue
	}

	hashDir "$d"
done

exit $errs
