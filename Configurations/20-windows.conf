## -*- mode: perl; -*-
# Copyright 2015-2018 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html

# Helper functions for the Windows configs
my $vc_win64a_info = {};
sub vc_win64a_info {
    unless (%$vc_win64a_info) {
        if (`nasm -v 2>NUL` =~ /NASM version ([0-9]+\.[0-9]+)/ && $1 >= 2.0) {
            $vc_win64a_info = { as        => "nasm",
                                asflags   => "-f win64 -DNEAR -Ox -g",
                                asoutflag => "-o" };
        } elsif ($disabled{asm}) {
            $vc_win64a_info = { as        => "ml64",
                                asflags   => "/c /Cp /Cx /Zi",
                                asoutflag => "/Fo" };
        } else {
            $die->("NASM not found - please read INSTALL and NOTES.WIN for further details\n");
            $vc_win64a_info = { as        => "{unknown}",
                                asflags   => "",
                                asoutflag => "" };
        }
    }
    return $vc_win64a_info;
}

my $vc_win32_info = {};
sub vc_win32_info {
    unless (%$vc_win32_info) {
        my $ver=`nasm -v 2>NUL`;
        my $vew=`nasmw -v 2>NUL`;
        if ($ver ne "" || $vew ne "") {
            $vc_win32_info = { as        => $ver ge $vew ? "nasm" : "nasmw",
                               asflags   => "-f win32",
                               asoutflag => "-o",
                               perlasm_scheme => "win32n" };
        } elsif ($disabled{asm}) {
            $vc_win32_info = { as        => "ml",
                               asflags   => "/nologo /Cp /coff /c /Cx /Zi",
                               asoutflag => "/Fo",
                               perlasm_scheme => "win32" };
        } else {
            $die->("NASM not found - please read INSTALL and NOTES.WIN for further details\n");
            $vc_win32_info = { as        => "{unknown}",
                               asflags   => "",
                               asoutflag => "",
                               perlasm_scheme => "win32" };
        }
    }
    return $vc_win32_info;
}

(
#### Visual C targets
#
# Win64 targets, WIN64I denotes IA-64 and WIN64A - AMD64
#
# Note about -wd4090, disable warning C4090. This warning returns false
# positives in some situations. Disabling it altogether masks both
# legitimate and false cases, but as we compile on multiple platforms,
# we rely on other compilers to catch legitimate cases.
#
# Also note that we force threads no matter what.  Configuring "no-threads"
# is ignored.
    "VC-common" => {
        inherit_from     => [ "BASE_Windows" ],
        template         => 1,
        cc               => "cl",
        cflags           => "-W3 -wd4090 -Gs0 -GF -Gy -nologo -DOPENSSL_SYS_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -D_CRT_SECURE_NO_DEPRECATE -D_WINSOCK_DEPRECATED_NO_WARNINGS",
        defines          => add(sub { my @defs = ();
                                      unless ($disabled{"zlib-dynamic"}) {
                                          my $zlib =
                                              $withargs{zlib_lib} // "ZLIB1";
                                          push @defs,
                                              quotify("perl",
                                                      'LIBZ="' . $zlib . '"');
                                      }
                                      return [ @defs ];
                                    }),
        coutflag         => "/Fo",
        lib_cflags       => add("/Zi /Fdossl_static"),
        dso_cflags       => "/Zi /Fddso",
        bin_cflags       => "/Zi /Fdapp",
        lflags           => add("/debug"),
        shared_ldflag    => "/dll",
        shared_target    => "win-shared", # meaningless except it gives Configure a hint
        thread_scheme    => "winthreads",
        dso_scheme       => "win32",
        apps_aux_src     => add("win32_init.c"),
    },
    "VC-noCE-common" => {
        inherit_from     => [ "VC-common" ],
        template         => 1,
        cflags           => add(picker(default => "-DUNICODE -D_UNICODE",
                                       debug   =>
                                       sub {
                                           ($disabled{shared} ? "" : "/MDd")
                                               ." /Od -DDEBUG -D_DEBUG";
                                       },
                                       release =>
                                       sub {
                                           ($disabled{shared} ? "" : "/MD")
                                               ." /O2";
                                       })),
        lib_cflags       => add(sub { $disabled{shared} ? "/MT /Zl" : () }),
        # Following might/should appears controversial, i.e. defining
        # /MDd without evaluating $disabled{shared}. It works in
        # non-shared build because static library is compiled with /Zl
        # and bares no reference to specific RTL. And it works in
        # shared build because multiple /MDd options are not prohibited.
        # But why /MDd in static build? Well, basically this is just a
        # reference point, which allows to catch eventual errors that
        # would prevent those who want to wrap OpenSSL into own .DLL.
        # Why not /MD in release build then? Well, some are likely to
        # prefer [non-debug] openssl.exe to be free from Micorosoft RTL
        # redistributable.
        bin_cflags       => add(picker(debug   => "/MDd",
                                       release => sub { $disabled{shared} ? "/MT" : () },
                                      )),
        bin_lflags       => add("/subsystem:console /opt:ref"),
        ex_libs          => add(sub {
            my @ex_libs = ();
            push @ex_libs, 'ws2_32.lib' unless $disabled{sock};
            push @ex_libs, 'gdi32.lib advapi32.lib crypt32.lib user32.lib';
            return join(" ", @ex_libs);
        }),
    },
    "VC-WIN64-common" => {
        inherit_from     => [ "VC-noCE-common" ],
        template         => 1,
        ex_libs          => add(sub {
            my @ex_libs = ();
            push @ex_libs, 'bufferoverflowu.lib' if (`cl 2>&1` =~ /14\.00\.4[0-9]{4}\./);
            return join(" ", @_, @ex_libs);
        }),
        bn_ops           => "SIXTY_FOUR_BIT EXPORT_VAR_AS_FN",
        build_scheme     => add("VC-W64", { separator => undef }),
    },
    "VC-WIN64I" => {
        inherit_from     => [ "VC-WIN64-common", asm("ia64_asm"),
                              sub { $disabled{shared} ? () : "ia64_uplink" } ],
        as               => "ias",
        asflags          => "-d debug",
        asoutflag        => "-o",
        sys_id           => "WIN64I",
        bn_asm_src       => sub { return undef unless @_;
                                  my $r=join(" ",@_); $r=~s|bn-ia64.s|bn_asm.c|; $r; },
        perlasm_scheme   => "ias",
        multilib         => "-ia64",
    },
    "VC-WIN64A" => {
        inherit_from     => [ "VC-WIN64-common", asm("x86_64_asm"),
                              sub { $disabled{shared} ? () : "x86_64_uplink" } ],
        as               => sub { vc_win64a_info()->{as} },
        asflags          => sub { vc_win64a_info()->{asflags} },
        asoutflag        => sub { vc_win64a_info()->{asoutflag} },
        sys_id           => "WIN64A",
        bn_asm_src       => sub { return undef unless @_;
                                  my $r=join(" ",@_); $r=~s|asm/x86_64-gcc|bn_asm|; $r; },
        perlasm_scheme   => "auto",
        multilib         => "-x64",
    },
    "VC-WIN32" => {
        # x86 Win32 target defaults to ANSI API, if you want UNICODE,
        # configure with 'perl Configure VC-WIN32 -DUNICODE -D_UNICODE'
        inherit_from     => [ "VC-noCE-common", asm("x86_asm"),
                              sub { $disabled{shared} ? () : "uplink_common" } ],
        cflags           => add("-WX"),
        as               => sub { vc_win32_info()->{as} },
        asflags          => sub { vc_win32_info()->{asflags} },
        asoutflag        => sub { vc_win32_info()->{asoutflag} },
        ex_libs          => add(sub {
            my @ex_libs = ();
            # WIN32 UNICODE build gets linked with unicows.lib for
            # backward compatibility with Win9x.
            push @ex_libs, 'unicows.lib'
                if (grep { $_ eq "UNICODE" } @user_defines);
            return join(" ", @ex_libs, @_);
        }),
        sys_id           => "WIN32",
        bn_ops           => "BN_LLONG EXPORT_VAR_AS_FN",
        perlasm_scheme   => sub { vc_win32_info()->{perlasm_scheme} },
        build_scheme     => add("VC-W32", { separator => undef }),
    },

#### MinGW
    "mingw" => {
        inherit_from     => [ "BASE_unix", asm("x86_asm"),
                              sub { $disabled{shared} ? () : "x86_uplink" } ],
        cc               => "gcc",
        cflags           => combine(picker(default => "-DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DUNICODE -D_UNICODE -m32 -Wall",
                                           debug   => "-g -O0",
                                           release => "-O3 -fomit-frame-pointer"),
                                    threads("-D_MT")),
        sys_id           => "MINGW32",
        ex_libs          => add("-lws2_32 -lgdi32 -lcrypt32"),
        bn_ops           => "BN_LLONG EXPORT_VAR_AS_FN",
        thread_scheme    => "winthreads",
        perlasm_scheme   => "coff",
        dso_scheme       => "win32",
        shared_target    => "mingw-shared",
        shared_cflag     => add("-D_WINDLL"),
        shared_ldflag    => "-static-libgcc",
        shared_rcflag    => "--target=pe-i386",
        shared_extension => ".dll",
        multilib         => "",
        apps_aux_src     => add("win32_init.c"),
    },
    "mingw64" => {
        # As for OPENSSL_USE_APPLINK. Applink makes it possible to use
        # .dll compiled with one compiler with application compiled with
        # another compiler. It's possible to engage Applink support in
        # mingw64 build, but it's not done, because till mingw64
        # supports structured exception handling, one can't seriously
        # consider its binaries for using with non-mingw64 run-time
        # environment. And as mingw64 is always consistent with itself,
        # Applink is never engaged and can as well be omitted.
        inherit_from     => [ "BASE_unix", asm("x86_64_asm") ],
        cc               => "gcc",
        cflags           => combine(picker(default => "-DL_ENDIAN -DWIN32_LEAN_AND_MEAN -DUNICODE -D_UNICODE -m64 -Wall",
                                           debug   => "-g -O0",
                                           release => "-O3"),
                                    threads("-D_MT")),
        sys_id           => "MINGW64",
        ex_libs          => add("-lws2_32 -lgdi32 -lcrypt32"),
        bn_ops           => "SIXTY_FOUR_BIT EXPORT_VAR_AS_FN",
        thread_scheme    => "winthreads",
        perlasm_scheme   => "mingw64",
        dso_scheme       => "win32",
        shared_target    => "mingw-shared",
        shared_cflag     => add("-D_WINDLL"),
        shared_ldflag    => "-static-libgcc",
        shared_rcflag    => "--target=pe-x86-64",
        shared_extension => ".dll",
        multilib         => "64",
        apps_aux_src     => add("win32_init.c"),
    },
);
