## -*- mode: perl; -*-
# Copyright 2015-2018 The OpenSSL Project Authors. All Rights Reserved.
#
# Licensed under the OpenSSL license (the "License").  You may not use
# this file except in compliance with the License.  You can obtain a copy
# in the file LICENSE in the source distribution or at
# https://www.openssl.org/source/license.html

(
####
#### Variety of LINUX:-)
####
    # linux-generic32 and linuxx-generic64 are defined in 10-linux.conf
    "linux-ppc" => {
        inherit_from     => [ "linux-generic32", asm("ppc32_asm") ],
        perlasm_scheme   => "linux32",
    },
    "linux-ppc64" => {
        inherit_from     => [ "linux-generic64", asm("ppc64_asm") ],
        cflags           => add("-m64 -DB_ENDIAN"),
        perlasm_scheme   => "linux64",
        multilib         => "64",
    },
    "linux-ppc64le" => {
        inherit_from     => [ "linux-generic64", asm("ppc64_asm") ],
        cflags           => add("-m64 -DL_ENDIAN"),
        perlasm_scheme   => "linux64le",
    },

    "linux-armv4" => {
        ################################################################
        # Note that -march is not among compiler options in linux-armv4
        # target description. Not specifying one is intentional to give
        # you choice to:
        #
        # a) rely on your compiler default by not specifying one;
        # b) specify your target platform explicitly for optimal
        # performance, e.g. -march=armv6 or -march=armv7-a;
        # c) build "universal" binary that targets *range* of platforms
        # by specifying minimum and maximum supported architecture;
        #
        # As for c) option. It actually makes no sense to specify
        # maximum to be less than ARMv7, because it's the least
        # requirement for run-time switch between platform-specific
        # code paths. And without run-time switch performance would be
        # equivalent to one for minimum. Secondly, there are some
        # natural limitations that you'd have to accept and respect.
        # Most notably you can *not* build "universal" binary for
        # big-endian platform. This is because ARMv7 processor always
        # picks instructions in little-endian order. Another similar
        # limitation is that -mthumb can't "cross" -march=armv6t2
        # boundary, because that's where it became Thumb-2. Well, this
        # limitation is a bit artificial, because it's not really
        # impossible, but it's deemed too tricky to support. And of
        # course you have to be sure that your binutils are actually
        # up to the task of handling maximum target platform. With all
        # this in mind here is an example of how to configure
        # "universal" build:
        #
        # ./Configure linux-armv4 -march=armv6 -D__ARM_MAX_ARCH__=8
        #
        inherit_from     => [ "linux-generic32", asm("armv4_asm") ],
        perlasm_scheme   => "linux32",
    },
    "linux-aarch64" => {
        inherit_from     => [ "linux-generic64", asm("aarch64_asm") ],
        perlasm_scheme   => "linux64",
    },
    "linux-arm64ilp32" => {  # https://wiki.linaro.org/Platform/arm64-ilp32
        inherit_from     => [ "linux-generic32", asm("aarch64_asm") ],
        cflags           => add("-mabi=ilp32"),
        bn_ops           => "SIXTY_FOUR_BIT RC4_CHAR",
        perlasm_scheme   => "linux64",
    },

    "linux-mips32" => {
        # Configure script adds minimally required -march for assembly
        # support, if no -march was specified at command line.
        inherit_from     => [ "linux-generic32", asm("mips32_asm") ],
        cflags           => add("-mabi=32 -DBN_DIV3W"),
        perlasm_scheme   => "o32",
    },
    # mips32 and mips64 below refer to contemporary MIPS Architecture
    # specifications, MIPS32 and MIPS64, rather than to kernel bitness.
    "linux-mips64" => {
        inherit_from     => [ "linux-generic32", asm("mips64_asm") ],
        cflags           => add("-mabi=n32 -DBN_DIV3W"),
        bn_ops           => "SIXTY_FOUR_BIT RC4_CHAR",
        perlasm_scheme   => "n32",
        multilib         => "32",
    },
    "linux64-mips64" => {
        inherit_from     => [ "linux-generic64", asm("mips64_asm") ],
        cflags           => add("-mabi=64 -DBN_DIV3W"),
        perlasm_scheme   => "64",
        multilib         => "64",
    },

    #### IA-32 targets...
    #### These two targets are a bit aged and are to be used on older Linux
    #### machines where gcc doesn't understand -m32 and -m64
    "linux-elf" => {
        inherit_from     => [ "linux-generic32", asm("x86_elf_asm") ],
        cflags           => add(picker(default => "-DL_ENDIAN",
                                       release => "-fomit-frame-pointer")),
        bn_ops           => "BN_LLONG",
    },
    "linux-aout" => {
        inherit_from     => [ "BASE_unix", asm("x86_asm") ],
        cc               => "gcc",
        cflags           => add(picker(default => "-DL_ENDIAN -Wall",
                                       debug   => "-O0 -g",
                                       release => "-O3 -fomit-frame-pointer")),
        bn_ops           => "BN_LLONG",
        thread_scheme    => "(unknown)",
        perlasm_scheme   => "a.out",
    },

    "linux-x32" => {
        inherit_from     => [ "linux-generic32", asm("x86_64_asm") ],
        cflags           => add("-mx32 -DL_ENDIAN"),
        bn_ops           => "SIXTY_FOUR_BIT",
        perlasm_scheme   => "elf32",
        multilib         => "x32",
    },

    "linux-ia64" => {
        inherit_from     => [ "linux-generic64", asm("ia64_asm") ],
        bn_ops           => "SIXTY_FOUR_BIT_LONG",
    },

    "linux64-s390x" => {
        inherit_from     => [ "linux-generic64", asm("s390x_asm") ],
        cflags           => add("-m64 -DB_ENDIAN"),
        perlasm_scheme   => "64",
        multilib         => "64",
    },
    "linux32-s390x" => {
        #### So called "highgprs" target for z/Architecture CPUs
        # "Highgprs" is kernel feature first implemented in Linux
        # 2.6.32, see /proc/cpuinfo. The idea is to preserve most
        # significant bits of general purpose registers not only
        # upon 32-bit process context switch, but even on
        # asynchronous signal delivery to such process. This makes
        # it possible to deploy 64-bit instructions even in legacy
        # application context and achieve better [or should we say
        # adequate] performance. The build is binary compatible with
        # linux-generic32, and the idea is to be able to install the
        # resulting libcrypto.so alongside generic one, e.g. as
        # /lib/highgprs/libcrypto.so.x.y, for ldconfig and run-time
        # linker to autodiscover. Unfortunately it doesn't work just
        # yet, because of couple of bugs in glibc
        # sysdeps/s390/dl-procinfo.c affecting ldconfig and ld.so.1...
        #
        inherit_from     => [ "linux-generic32", asm("s390x_asm") ],
        cflags           => add("-m31 -Wa,-mzarch -DB_ENDIAN"),
        bn_asm_src       => sub { my $r=join(" ",@_); $r=~s|asm/s390x\.S|bn_asm.c|; $r; },
        perlasm_scheme   => "31",
        multilib         => "/highgprs",
    },

    #### SPARC Linux setups
    "linux-sparcv8" => {
        inherit_from     => [ "linux-generic32", asm("sparcv8_asm") ],
        cflags           => add("-mcpu=v8 -DB_ENDIAN -DBN_DIV2W"),
    },
    "linux-sparcv9" => {
        # it's a real mess with -mcpu=ultrasparc option under Linux,
        # but -Wa,-Av8plus should do the trick no matter what.
        inherit_from     => [ "linux-generic32", asm("sparcv9_asm") ],
        cflags           => add("-m32 -mcpu=ultrasparc -Wa,-Av8plus -DB_ENDIAN -DBN_DIV2W"),
    },
    "linux64-sparcv9" => {
        # GCC 3.1 is a requirement
        inherit_from     => [ "linux-generic64", asm("sparcv9_asm") ],
        cflags           => add("-m64 -mcpu=ultrasparc -DB_ENDIAN"),
        bn_ops           => "BN_LLONG RC4_CHAR",
        multilib         => "64",
    },

    "linux-alpha-gcc" => {
        inherit_from     => [ "linux-generic64", asm("alpha_asm") ],
        cflags           => add("-DL_ENDIAN"),
        bn_ops           => "SIXTY_FOUR_BIT_LONG",
    },
    "linux-c64xplus" => {
        inherit_from     => [ "BASE_unix" ],
        # TI_CGT_C6000_7.3.x is a requirement
        cc               => "cl6x",
        cflags           => combine("--linux -ea=.s -eo=.o -mv6400+ -o2 -ox -ms -pden -DOPENSSL_SMALL_FOOTPRINT",
                                    threads("-D_REENTRANT")),
        bn_ops           => "BN_LLONG",
        cpuid_asm_src    => "c64xpluscpuid.s",
        bn_asm_src       => "asm/bn-c64xplus.asm c64xplus-gf2m.s",
        aes_asm_src      => "aes-c64xplus.s aes_cbc.c aes-ctr.fake",
        sha1_asm_src     => "sha1-c64xplus.s sha256-c64xplus.s sha512-c64xplus.s",
        rc4_asm_src      => "rc4-c64xplus.s",
        modes_asm_src    => "ghash-c64xplus.s",
        chacha_asm_src   => "chacha-c64xplus.s",
        poly1305_asm_src => "poly1305-c64xplus.s",
        thread_scheme    => "pthreads",
        perlasm_scheme   => "void",
        dso_scheme       => "dlfcn",
        shared_target    => "linux-shared",
        shared_cflag     => "--pic",
        shared_ldflag    => add("-z --sysv --shared"),
        shared_extension => ".so.\$(SHLIB_VERSION_NUMBER)",
        ranlib           => "true",
    },

#### uClinux
    "uClinux-dist" => {
        inherit_from     => [ "BASE_unix" ],
        cc               => sub { env('CC') },
        cflags           => combine(threads("-D_REENTRANT")),
        ex_libs          => add("\$(LDLIBS)"),
        bn_ops           => "BN_LLONG",
        thread_scheme    => "pthreads",
        dso_scheme       => sub { env('LIBSSL_dlfcn') },
        shared_target    => "linux-shared",
        shared_cflag     => "-fPIC",
        shared_extension => ".so.\$(SHLIB_VERSION_NUMBER)",
        ranlib           => sub { env('RANLIB') },
    },
    "uClinux-dist64" => {
        inherit_from     => [ "BASE_unix" ],
        cc               => sub { env('CC') },
        cflags           => combine(threads("-D_REENTRANT")),
        ex_libs          => add("\$(LDLIBS)"),
        bn_ops           => "SIXTY_FOUR_BIT_LONG",
        thread_scheme    => "pthreads",
        dso_scheme       => sub { env('LIBSSL_dlfcn') },
        shared_target    => "linux-shared",
        shared_cflag     => "-fPIC",
        shared_extension => ".so.\$(SHLIB_VERSION_NUMBER)",
        ranlib           => sub { env('RANLIB') },
    },
);
